// ***************************************************************************
// *                                                                         *
// *             STEFANO CURTAROLO - Duke University 2003-2020               *
// *                                                                         *
// ***************************************************************************

#include "../aflow.h"
#include "aflow_apl.h"

#define _ASTROPT_APL_OLD_ string("[AFLOW_PHONONS]") //CO20170601, ensure backwards compatibility (we ALWAYS support LEGACY)
#define _ASTROPT_APL_ string("[AFLOW_APL]") //CO20170601
#define _ASTROPT_QHA_ string("[AFLOW_QHA]") //CO20170601
#define _ASTROPT_AAPL_ string("[AFLOW_AAPL]") //CO20170601
//temporary directory for storing QHA files
#define _TMPDIR_ string("ARUN.APL.QH.TMP")  //[PN]
#define _STROPT_ string("[VASP_FORCE_OPTION]") //ME20181226

//AS20200427
#define NEW_QHA false

//CO fixing cpp version issues with auto_ptr (depreciated)
#if __cplusplus >= 201103L
template <typename T>
using auto_ptr = std::unique_ptr<T>;
#else
using std::auto_ptr;
#endif

static const string _ANHARMONIC_IFCS_FILE_[2] = {"anharmonicIFCs_3rd.xml", "anharmonicIFCs_4th.xml"};
static const int _NUM_RELAX_ = 2; //ME20181226
static const string _APL_RELAX_PREFIX_ = "relax_apl"; //ME20181226  //ME20190125

namespace KBIN {
  //ME20181107 - Relax structure with PREC=PHONONS before running APL
  //ME20200102 - Make k-point grid commensurate with supercell size
  bool relaxStructureAPL_VASP(int start_relax,
      const string& AflowIn,
      aurostd::xoption& aplopts,  //ME20200102
      const xvector<int>& scell_dims,  //ME20200102
      bool relax_commensurate,
      _xvasp& xvasp,
      _aflags& aflags,
      _kflags& kflags,
      _vflags& vflags,
      ofstream& fileMessage,
      ostream& oss) {
    string function = "KBIN::relaxStructureAPL_VASP():";
    stringstream message;

    if (start_relax == _NUM_RELAX_) return true;  // Nothing to do here

    // Store original settings
    string prec = vflags.KBIN_VASP_FORCE_OPTION_PREC.xscheme;
    bool prec_entry = vflags.KBIN_VASP_FORCE_OPTION_PREC.isentry;
    aurostd::xoption kbin_vasp_run = vflags.KBIN_VASP_RUN;
    int nrelax = xvasp.NRELAX;

    // Change to RELAX
    vflags.KBIN_VASP_RUN.flag("RELAX", true);
    vflags.KBIN_VASP_RUN.flag("STATIC", false);
    vflags.KBIN_VASP_RUN.flag("RELAX_STATIC", false);
    vflags.KBIN_VASP_RUN.flag("RELAX_STATIC_BANDS", false);
    vflags.KBIN_VASP_RUN.flag("STATIC_BANDS", false);

    // Change to phonon settings
    string prec_phonons = xvasp.aplopts.getattachedscheme("AFLOWIN_FLAG::APL_PREC");
    vflags.KBIN_VASP_FORCE_OPTION_PREC.pop(prec);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.push(prec_phonons);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.isentry = true;

    //ME20200427
    bool Krun = true;
    if (relax_commensurate) {
      // Determine k-point grid that is commensurate with the grid of the supercell
      //ME20200102
      // Determine k-point grid that is commensurate with the k-point grid of
      // the supercell. APL automatically chooses the k-point grid for the
      // relaxation to be commensurate with the k-point grid for the supercell.
      // For example, if a 3x2x1 supercell uses a 2x2x3 k-point grid, the unit
      // cell will be relaxed using a 6x4x3 k-point grid. This minimizes the
      // risk of ghost forces in the supercell calculations.
      apl::Supercell scell(xvasp.str, fileMessage, aflags.Directory, oss);
      scell.build(scell_dims, false);
      string scheme_phonons = vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.content_string;
      int kppra_phonons = vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.content_int;
      xvector<int> kpts_sc(3), kpts_pc(3);
      if (vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) {
        int NK = (int) ((double) kppra_phonons/scell.getSupercellStructure().atoms.size() + 0.5);
        if (NK < 1) NK = 1;
        KPPRA(kpts_sc[1], kpts_sc[2], kpts_sc[3], scell.getSupercellStructure().lattice, NK);
      } else {
        vector<int> kpts;
        aurostd::string2tokens(vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string, kpts, " xX");
        kpts_sc = aurostd::vector2xvector(kpts);
      }
      for (int i = 1; i < 4; i++) kpts_pc[i] = scell_dims[i] * kpts_sc[i];
      message << "Relaxations will be performed on a " << aurostd::joinWDelimiter(kpts_pc, "x") << " k-point grid.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags.Directory, fileMessage, oss);

      // Create k-points file
      stringstream kpts_file;
      kpts_file << "k-points automatically generated by APL, supercell = " << aurostd::joinWDelimiter(scell_dims, "x") << ",";
      if (vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) kpts_file << " kppra = " << kppra_phonons;
      kpts_file << " (k = " << aurostd::joinWDelimiter(kpts_sc, "x")  << ")" << std::endl;
      kpts_file << "0" << std::endl;
      kpts_file << scheme_phonons << std::endl;
      kpts_file << aurostd::joinWDelimiter(kpts_pc, " ") << std::endl;
      kpts_file << "0 0 0" << std::endl;

      // Store old settings and switch to k-points mode to explicit with new file
      aurostd::xoption kbin_vasp_kpoints_mode_back = vflags.KBIN_VASP_KPOINTS_MODE;
      aurostd::xoption kbin_vasp_kpoints_file_back = vflags.KBIN_VASP_KPOINTS_FILE;
      string kbin_vasp_kpoints_explicit_start_stop_back = vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str();
      vflags.KBIN_VASP_KPOINTS_MODE.clear();
      vflags.KBIN_VASP_KPOINTS_FILE.clear();
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str("");
      vflags.KBIN_VASP_KPOINTS_MODE.flag("EXPLICIT", true);
      vflags.KBIN_VASP_KPOINTS_MODE.flag("EXPLICIT_START_STOP", true);
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP << kpts_file.str();

      // Run relxations
      Krun = runRelaxationsAPL_VASP(start_relax, AflowIn, xvasp, aflags, kflags, vflags, fileMessage);

      // Consistency check: Redetermine the supercell dimensions and the k-point
      // grid for the supercell calculations with the relaxed structure. If they
      // do not agree, then the structure has changed too much and the relaxation
      // did not use an appropriate k-point grid.
      // The k-points scheme MUST be resolved pre-phonon-relaxation and made consistent
      // with the desired supercell dimensions, otherwise ghost-forces may appear.
      scell.clearSupercell();
      scell.initialize(xvasp.str);
      bool scell_verbose = aplopts.flag("SCELL::VERBOSE");
      aplopts.flag("SCELL::VERBOSE", false);
      xvector<int> scell_dims_new = scell.determineSupercellDimensions(aplopts);
      aplopts.flag("SCELL::VERBOSE", scell_verbose);
      if (scell_dims != scell_dims_new) {
        message << "Supercell dimensions of the input structure (" << aurostd::joinWDelimiter(scell_dims, "x") << ")"
          << " and the relaxed structure (" << aurostd::joinWDelimiter(scell_dims_new, "x") << ")"
          << " do not agree. This is likely due to different symmetries in these structures. Use"
          << " an input structure that is closer to the fully relaxed one, remove all"
          << " CONTCAR." << _APL_RELAX_PREFIX_ << "* files, and run APL again.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _RUNTIME_ERROR_);
      }
      // k-point grid comparison only relevant when KPPRA is used
      if (!vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) {
        xvector<int> kpts_sc_new(3);
        scell.build(scell_dims_new, false);
        int NK = (int) ((double) kppra_phonons/scell.getSupercellStructure().atoms.size() + 0.5);
        if (NK < 1) NK = 1;
        KPPRA(kpts_sc_new[1], kpts_sc_new[2], kpts_sc_new[3], scell.getSupercellStructure().lattice, NK);
        if (kpts_sc != kpts_sc_new) {
          message << "k-point grids of the supercells of the input structure (" << aurostd::joinWDelimiter(kpts_sc, "x") << ")"
            << " and the relaxed structure (" << aurostd::joinWDelimiter(kpts_sc_new, "x") <<  ")"
            << " do not agree. This is likely due to different symmetries in these structures. Use"
            << " an input structure that is closer to the fully relaxed one, remove all"
            << " CONTCAR." << _APL_RELAX_PREFIX_ << "* files, and run APL again.";
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _RUNTIME_ERROR_);
        }
      }

      // Restore original settings
      vflags.KBIN_VASP_KPOINTS_MODE = kbin_vasp_kpoints_mode_back;
      vflags.KBIN_VASP_KPOINTS_FILE = kbin_vasp_kpoints_file_back;
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str("");
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP << kbin_vasp_kpoints_explicit_start_stop_back;
    } else {
      Krun = runRelaxationsAPL_VASP(start_relax, AflowIn, xvasp, aflags, kflags, vflags, fileMessage);
    }

    vflags.KBIN_VASP_FORCE_OPTION_PREC.pop(prec_phonons);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.push(prec);
    vflags.KBIN_VASP_FORCE_OPTION_KPOINTS.isentry = prec_entry;
    xvasp.NRELAX = nrelax;
    vflags.KBIN_VASP_RUN = kbin_vasp_run;

    return Krun;
  }

  bool runRelaxationsAPL_VASP(int start_relax, const string& AflowIn, _xvasp& xvasp,
      _aflags& aflags, _kflags& kflags, _vflags& vflags, ofstream& fileMessage) {
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    ostringstream aus;

    bool Krun = VASP_Produce_and_Modify_INPUT(xvasp, AflowIn, fileMessage, aflags, kflags, vflags);
    Krun = (Krun && VASP_Write_INPUT(xvasp, vflags));

    //ME20200115 - set for SPIN_REMOVE_RELAX
    xvasp.NRELAX = _NUM_RELAX_;

    if (Krun) {
      int i;
      for (i = start_relax; Krun && i <= _NUM_RELAX_; i++) {
        aus << 11111*i << " RELAXATION APL - " << xvasp.Directory << " - K=[" << xvasp.str.kpoints_k1 << " " << xvasp.str.kpoints_k2 << " " << xvasp.str.kpoints_k3 << "]" << " - " << kflags.KBIN_BIN << " - " << Message(_AFLOW_MESSAGE_DEFAULTS_) << endl;
        aurostd::PrintMessageStream(fileMessage, aus, XHOST.QUIET);
        if (i < _NUM_RELAX_) {
          Krun = VASP_Run(xvasp, aflags, kflags, vflags, _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), true, fileMessage);
          XVASP_INCAR_SPIN_REMOVE_RELAX(xvasp, aflags, vflags, i, fileMessage);
          XVASP_KPOINTS_IBZKPT_UPDATE(xvasp, aflags, vflags, i, fileMessage);
        } else { 
          Krun = VASP_Run(xvasp, aflags, kflags, vflags, _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), true, fileMessage);
          XVASP_INCAR_SPIN_REMOVE_RELAX(xvasp, aflags, vflags, i, fileMessage);  //ME20200115 - or else SPIN_REMOVE_RELAX_2 does not work
        }
      }
      if (Krun && (i == _NUM_RELAX_)) {
        aus << 11111*i << " RELAXATION APL END - " << xvasp.Directory << " - K=[" << xvasp.str.kpoints_k1 << " " << xvasp.str.kpoints_k2 << " " << xvasp.str.kpoints_k3 << "]" << " - " << kflags.KBIN_BIN << " - " << Message(_AFLOW_MESSAGE_DEFAULTS_) << endl;
      }
    }
    if (!Krun) return false;

    // Update structure - do not set xvasp.str = str_fin or all other
    // information (species, PPs) will be deleted!
    stringstream xstr;
    string filename = aflags.Directory + "/CONTCAR." + _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(_NUM_RELAX_);  //ME20190308
    if (!aurostd::FileExist(filename)) return false;
    aurostd::file2stringstream(filename, xstr);
    xstructure str_fin(xstr, IOVASP_AUTO);
    // Restore species and PP information
    str_fin.species = xvasp.str.species; //ME20190109
    str_fin.species_pp = xvasp.str.species_pp; //ME20190109
    str_fin.species_pp_type = xvasp.str.species_pp_type; //ME20190109
    str_fin.species_pp_version = xvasp.str.species_pp_version; //ME20190109
    str_fin.species_pp_ZVAL = xvasp.str.species_pp_ZVAL; //ME20190109
    str_fin.species_pp_vLDAU = xvasp.str.species_pp_vLDAU; //ME20190109

    xvasp.str = str_fin; //ME20190109
    if(LDEBUG){std::cerr << xvasp.str << std::endl;} //ME20190308
    pflow::fixEmptyAtomNames(xvasp.str,true);  //ME20190308

    // Safeguard for when CONVERT is set in the aflow.in file
    // CONVERT_UNIT_CELL may shift the origin, so not doing it here
    // would lead to inconsistencies when between the supercell creation
    // and the APL/AAPL analysis
    //ME20200102 - should not be necessary anymore when the state is saved,
    // but it's good to convert it anyway to get "nicer" lattice vectors
    if (!vflags.KBIN_VASP_FORCE_OPTION_CONVERT_UNIT_CELL.flag("PRESERVE") &&
        !vflags.KBIN_VASP_FORCE_OPTION_CONVERT_UNIT_CELL.xscheme.empty()) { //ME20190109
      xvasp.str.Standard_Lattice_primitive = false;
      xvasp.str.Standard_Lattice_conventional = false;
      VASP_Convert_Unit_Cell(xvasp, vflags, aflags, fileMessage, aus);
    }

    return Krun;
  }

  void VASP_RunPhonons_APL(_xvasp& xvasp,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _vflags& vflags, ofstream& messageFile, ostream& oss) {
    _xinput xinput(xvasp);
    _xflags xflags(vflags);
    RunPhonons_APL(xinput,AflowIn,aflags,kflags,xflags,messageFile, oss);
  }

  void RunPhonons_APL(_xinput& xinput,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _xflags& xflags, 
      ofstream& messageFile,
      ostream& oss) {
    //ME20200107 - Wrap in a try statement so that faulty APL runs don't kill other post-processing
    try {
      RunPhonons_APL_20181216(xinput,AflowIn,aflags,kflags,xflags,messageFile);
    } catch (aurostd::xerror e) {
      pflow::logger(e.whereFileName(), e.whereFunction(), e.error_message, aflags.Directory, messageFile, oss, _LOGGER_ERROR_);
    }
  }
  void RunPhonons_APL_20181216(_xinput& xinput,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _xflags& xflags, 
      ofstream& messageFile,
      ostream& oss) {

    bool LDEBUG = (FALSE || XHOST.DEBUG);

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                               INITIALIZE                                //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    xinput.xvasp.AVASP_arun = true;
    string function = "KBIN::RunPhonons_APL():";  //ME20191029
    stringstream message;

    if (LDEBUG) std::cerr << function << " DEBUG [0]" << std::endl;
    // Test
    //if (!(kflags.KBIN_PHONONS_CALCULATION_APL || kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_AAPL)) return; //PN20180705
    if (!(kflags.KBIN_PHONONS_CALCULATION_APL ||
          kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C ||
          kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C ||
          kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C || //PN20180717
          kflags.KBIN_PHONONS_CALCULATION_AAPL)) return; //PN20180705

    //determine if we have a consistent mode defined between input and flags
    if(xinput.AFLOW_MODE_VASP){
      if(!xflags.AFLOW_MODE_VASP){
        cerr << "ERROR: KBIN::RunPhonons_APL: mismatch types between xinput(VASP) and xflags(!VASP)" << endl;
        return;
      }
    } else if(xinput.AFLOW_MODE_AIMS){
      if(!xflags.AFLOW_MODE_AIMS){
        cerr << "ERROR: KBIN::RunPhonons_APL: mismatch types between xinput(AIMS) and xflags(!AIMS)" << endl;
        return;
      }
    } //CO20200106 - patching for auto-indenting
    //else if(xinput.AFLOW_MODE_ALIEN){  //alien doesn't have xstr, so we ignore  //[CO20200106 - close bracket for indenting]}
    else {
      cerr << "ERROR: KBIN::RunPhonons_APL: unknown input type" << endl;
      return;
    }

    //CO
    //fix names if necessary, but do not remove pp info, we need mass!
    if(xinput.AFLOW_MODE_VASP){pflow::fixEmptyAtomNames(xinput.xvasp.str,true);}

    // Setup our logger
    apl::Logger logger(messageFile, aflags);
    //logger.setModuleName("PHONONS");  //will rename later

    string _ASTROPT_ = ""; //CO20170601
    string modulename = "";  //ME20200220 - for pflow::logger
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      logger.setModuleName("AAPL");  //CO20170601
      modulename = "AAPL";  //ME20200220
      _ASTROPT_ = _ASTROPT_AAPL_;    //CO20170601
    } else if (kflags.KBIN_PHONONS_CALCULATION_QHA || 
        kflags.KBIN_PHONONS_CALCULATION_QHA_A || 
        kflags.KBIN_PHONONS_CALCULATION_QHA_B || 
        kflags.KBIN_PHONONS_CALCULATION_QHA_C || 
        kflags.KBIN_PHONONS_CALCULATION_SCQHA ||
        kflags.KBIN_PHONONS_CALCULATION_SCQHA_A ||
        kflags.KBIN_PHONONS_CALCULATION_SCQHA_B ||
        kflags.KBIN_PHONONS_CALCULATION_SCQHA_C ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P_A ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P_B ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P_C) { //PN20180705
      logger.setModuleName("QHA");  //CO20170601
      modulename = "QHA";  //ME20200220
      _ASTROPT_ = _ASTROPT_QHA_;    //CO20170601
    } else {
      logger.setModuleName("APL");  //CO20170601
      modulename = "APL";  //ME20200220
      _ASTROPT_ = _ASTROPT_APL_;    //CO20170601
    }

    pflow::logger(_AFLOW_FILE_NAME_, modulename, "RUNNING...", aflags, messageFile, oss);

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                      READ PARAMETERS FROM AFLOWIN                       //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << function << " DEBUG [1a]" << std::endl;

    //ME20181019 - Overwrite defaults for CHGCAR, WAVECAR, etc. Only write
    // these files if the user explicitly sets these flags. Otherwise, APL will
    // use too much disk space.
    if (xinput.AFLOW_MODE_VASP) {
      xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.options2entry(AflowIn,_STROPT_+"BADER=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_BADER",xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.isentry && DEFAULT_VASP_FORCE_OPTION_BADER) {
        message << "Switching OFF BADER for APL calculations (default: OFF)."; //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.options2entry(AflowIn,_STROPT_+"CHGCAR=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_CHGCAR",xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.isentry && DEFAULT_VASP_FORCE_OPTION_CHGCAR) {
        message << "Switching OFF CHGCAR for APL calculations (default: OFF).";  //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.options2entry(AflowIn,_STROPT_+"ELF=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_ELF",xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.isentry && DEFAULT_VASP_FORCE_OPTION_ELF) {
        message << "Switching OFF ELF for APL calculations (default: OFF)."; //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.options2entry(AflowIn,_STROPT_+"WAVECAR=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_WAVECAR",xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.isentry && DEFAULT_VASP_FORCE_OPTION_WAVECAR) {
        message << "Switching OFF WAVECAR for APL calculations (default: OFF).";  //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      }
    }

    //ME20200427 - added grid option. It has priority, so check that the formatting is correct.
    if (xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.isentry) {
      vector<int> kpts;
      aurostd::string2tokens(xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string, kpts, " xX");
      if (kpts.size() != 3) {
        message << "Incorrect format for KPOINTS_GRID";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
    }

    // Make sure that the formatting for the k-point shift is correct
    if (xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_SHIFT.isentry) {
      vector<int> kpts;
      aurostd::string2tokens(xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_SHIFT.content_string, kpts, " ,;");
      if (kpts.size() != 3) {
        message << "Incorrect format for KPOINTS_SHIFT";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
    }

    // APL ----------------------------------------------------------------------

    if (LDEBUG) std::cerr << function << " DEBUG [1b]" << std::endl;

    /***************************** READ PARAMETERS *****************************/

    aurostd::xoption aplopts;
    int USER_MAXSHELL = 0;
    for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.aplflags.size(); i++) {
      const string& key = kflags.KBIN_MODULE_OPTIONS.aplflags[i].keyword;
      message << (kflags.KBIN_MODULE_OPTIONS.aplflags[i].isentry? "Setting" : "DEFAULT") << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme;
      pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      aplopts.flag(key, kflags.KBIN_MODULE_OPTIONS.aplflags[i].option);
      aplopts.push_attached(key, kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme);
    }

    /***************************** CHECK PARAMETERS *****************************/

    apl::validateParametersAPL(aplopts, aflags, messageFile, oss);
    aplopts.flag("SUPERCELL::VERBOSE", true);  // Use verbose output for supercell construction

    // Process some APL strings
    // Relax structure
    int START_RELAX = 0;
    if (aplopts.flag("RELAX")) {
      START_RELAX = 1;
      if(xinput.AFLOW_MODE_VASP){
        // Check if the structure has already been relaxed
        for (int i = 1; i <= _NUM_RELAX_; i++) {
          string contcar = aflags.Directory + "/CONTCAR." + _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i);
          if (aurostd::EFileExist(contcar) || aurostd::FileExist(contcar)) {  //ME20200103 - also look for uncompressed files
            START_RELAX++;
          } else {
            break;
          }
        }
        if (START_RELAX == _NUM_RELAX_ + 1) {
          message << "Structure has already been relaxed. Relaxation will be skipped.";
          aplopts.flag("RELAX", false);
        } else if (START_RELAX != 1) {
          message << "APL has already performed " << (START_RELAX + 1) << " relaxations.";
          message << " Number of relaxations remaining: " << (_NUM_RELAX_ - START_RELAX + 1) << ".";
        }
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      } else {
        aplopts.flag("RELAX", false);
        message << "RELAX option only supported for VASP. Relaxations will be skipped.";
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
      }
    }

    // DOS
    vector<string> tokens;
    vector<int> USER_DOS_MESH;
    vector<xvector<double> > USER_DOS_PROJECTIONS;
    if (aplopts.flag("DOS") || aplopts.flag("TP")) {  //ME20190423
      aurostd::string2tokens(aplopts.getattachedscheme("DOSMESH"), USER_DOS_MESH, " xX");
      // ME20190625 - projected DOS
      // ME20200213 - now has fully atom projected DOS (use zero vector to indicate)
      if (aplopts.flag("DOS_PROJECT")) {
        if (aplopts.flag("DOS_CART") || aplopts.flag("DOS_FRAC")) {
          string projscheme = "";
          if (aplopts.flag("DOS_CART")) projscheme = aplopts.getattachedscheme("DOSPROJECTIONS_CART");
          else projscheme = aplopts.getattachedscheme("DOSPROJECTIONS_FRAC");
          aurostd::string2tokens(projscheme, tokens, "; ");
          vector<double> proj;
          for (uint i = 0; i < tokens.size(); i++) {
            aurostd::string2tokens(tokens[i], proj, ", ");
            USER_DOS_PROJECTIONS.push_back(aurostd::vector2xvector<double>(proj));
          }
        } else {
          xvector<double> proj(3);
          USER_DOS_PROJECTIONS.push_back(proj);
        }
      }
    }

    /****************************** OUTPUT SUMMARY ******************************/

    message << "Parameters for the Automatic Phonon Library successfully read." << std::endl;
    message << "The structure will " << (aplopts.flag("RELAX")?"":"NOT ") << "be relaxed before running APL." << std::endl;
    message << "The hibernate feature is switched " << (aplopts.flag("HIBERNATE")?"ON":"OFF") << "." << std::endl;
    message << "Phonons will be calculated using the " << (aplopts.getattachedscheme("ENGINE")=="DM"?"Direct":"Linear Response") << " Method." << std::endl;

    if (aplopts.getattachedscheme("ENGINE") == "DM") {
      message << "The distortion magnitude will be " << aplopts.getattachedscheme("DMAG") << " Angstrom." << std::endl;
      if (aplopts.flag("DXYZONLY")) {
        message << "Only distortions along the lattice vectors will be used." << std::endl;
      } else {
        message << "Atoms will be distorted along the lattice vectors, face diagonals, and body diagonals." << std::endl;
      }
      if (aplopts.flag("DSYMMETRIZE")) {
        message << "Non-symmetric distortion directions will be determined for each site." << std::endl;
      } else {
        message << "Distortions will be generated in three independent directions." << std::endl;
      }
      if (aplopts.flag("DSYMMETRIZE")) { //CO20190131
        message << "Distortion directions will be determined for inequivalent sites only." << std::endl;
      } else {
        message << "Distortion directions will be determined for ALL sites." << std::endl;
      }
      // Output now so that the warning about positive directions are can be displayed properly
      pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      if (aurostd::toupper(aplopts.getattachedscheme("DPM"))[0] == 'A') {
        message << "Positive/negative distortion directions will be determined for each site."; 
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      } else if (aplopts.flag("DPM")) {
        message << "Distortions will be generated in both the positive and negative direction.";
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      } else {
        message << "Distortions will only be generated in the positive direction - this is NOT recommended.";
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
      }
      message << "Forces from the undistored state will " << (aplopts.flag("ZEROSTATE")?"":"NOT ") << "be used." << std::endl;
    }

    message << "Polar corrections will " << (aplopts.flag("POLAR")?"":"NOT ") << "be employed." << std::endl;
    message << "Frequencies will be returned in this format: " << aplopts.getattachedscheme("FREQFORMAT") << "." << std::endl;

    message << "The supercell will be built using ";
    if (aplopts.flag("SUPERCELL")) {
      message << "the dimensions " << aplopts.getattachedscheme("SUPERCELL::VALUE") << "." << std::endl;
    } else if (aplopts.flag("MINATOMS") || aplopts.flag("MINATOMS_RESTRICTED")) {
      message << "at least " << aplopts.getattachedscheme("SUPERCELL::VALUE") << " atoms." << std::endl;
    } else if (aplopts.flag("MINSHELLS")) {
      message << "at least " << aplopts.getattachedscheme("SUPERCELL:VALUE") << " shells." << std::endl;
    }

    if (aplopts.flag("DC")) {
      message << "Phonon dispersion curves will be calculated ";
      if (aplopts.getattachedscheme("DCPATH") == "LATTICE") {
        message << "using the default path of the lattice (see DOI 10.1016/j.commatsci.2010.05.010). ";
      } else {
        string dc_initcoords_frac = aplopts.getattachedscheme("DCINITCOORDSFRAC");
        string dc_initcoords_cart = aplopts.getattachedscheme("DCINITCOORDSCART");
        message << "along the " << (aplopts.flag("DC_CART")?"Cartesian":"fractional") << " coordinates ";
        message << "[" << (aplopts.flag("DC_CART")?aplopts.getattachedscheme("DCINITCOORDSCART"):aplopts.getattachedscheme("DCINITCOORDSFRAC")) << "].";
      }
      message << " Each subpath will be divided into " << aplopts.getattachedscheme("DCPOINTS") << " points." << std::endl;
    } else {
      message << "Phonon dispersion curves will NOT be calculated." << std::endl;
    }

    if (aplopts.flag("DOS") || aplopts.flag("TP")) {  //ME20190423
      string dosmethod = aplopts.getattachedscheme("DOSMETHOD");
      message << "Phonon DOS will be calculated using the ";
      message << (dosmethod == "LT"?"Linear Tetrahedron":"Root Sampling") << " method ";
      message << "along a " << aplopts.getattachedscheme("DOSMESH");
      message << " mesh with " << aplopts.getattachedscheme("DOSPOINTS") << " bins.";
      if (dosmethod == "RS")
        message << " A smearing value of " << aplopts.getattachedscheme("DOSSMEAR") << " eV will be used.";
      //ME20190626 - projected DOS
      if ((USER_DOS_PROJECTIONS.size() == 0) || (dosmethod == "RS")) {
        message << " Projected phonon DOS will NOT be calculated.";
      } else {
        message << " Projected phonon DOS will be calculated along the "
          << (aplopts.flag("DOS_CART")?"fractional":"Cartesian") << " directions ";
        for (uint i = 0; i < USER_DOS_PROJECTIONS.size(); i++) {
          message << "[" << aurostd::joinWDelimiter(aurostd::vecDouble2vecString(aurostd::xvector2vector<double>(USER_DOS_PROJECTIONS[i])), ", ") << "]";
          message << ((i < USER_DOS_PROJECTIONS.size() - 1)?", ":".");
        }
      }
      message << std::endl;
    } else {
      message << "Phonon DOS will NOT be calculated." << std::endl;
    }

    if (aplopts.flag("TP")) {
      message << "Thermodynamic properties will be calculated between ";
      message << aplopts.getattachedscheme("TSTART") << " K and " << aplopts.getattachedscheme("TEND") << " K ";
      message << "in " << aplopts.getattachedscheme("TSTEP") << " K steps." << std::endl;
    } else {
      message << "Thermodynamic properties will NOT be calculated." << std::endl;
    }
    pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
    //ME20181026 END

    // AAPL ----------------------------------------------------------------------

    if (LDEBUG) std::cerr << function << " DEBUG [1c]" << std::endl;

    //ME20181027 START

    /***************************** READ PARAMETERS *****************************/

    bool USER_TCOND = false;
    aurostd::xoption aaplopts;
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      USER_TCOND = true;
      stringstream message;
      for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.aaplflags.size(); i++) {
        const string& key = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].keyword;
        message << (kflags.KBIN_MODULE_OPTIONS.aaplflags[i].isentry? "Setting" : "DEFAULT") << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme;
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
        aaplopts.flag(key, kflags.KBIN_MODULE_OPTIONS.aaplflags[i].option);
        aaplopts.push_attached(key, kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme);
      }
      apl::validateParametersAAPL(aaplopts, aflags, messageFile, oss);
      // Additional parameters from APL
      aaplopts.push_attached("DMAG", aplopts.getattachedscheme("DMAG"));
      aaplopts.flag("ZEROSTATE", aplopts.flag("ZEROSTATE"));
      vector<string> tokens;

      /****************************** OUTPUT SUMMARY ******************************/

      message << "Parameters for the Automatic Anharmonic Phonon Library successfully read." << std::endl;
      message << "Four-phonon processes will " << (aaplopts.flag("FOURTH_ORDER")?"":"NOT ") << "be included in the calculations.";

      bool defaults = (!aaplopts.flag("CUT_RAD") && !aaplopts.flag("CUT_SHELL"));
      if (defaults || aaplopts.flag("CUT_RAD")) {
        aurostd::string2tokens(aaplopts.getattachedscheme("CUT_RAD"), tokens, ",");
        message << "The cutoff to compute the 3rd order anharmonic IFCs will be ";
        message << tokens[0] << " Angstrom." << std::endl;
        if (aaplopts.flag("FOUTH_ORDER")) {
          message << "The cutoff to compute the 4th order anharmonic IFCs will be ";
          message << tokens[1] << " Angstrom." << std::endl;
        }
      }
      if (defaults || aaplopts.flag("CUT_RAD")) {
        aurostd::string2tokens(aaplopts.getattachedscheme("CUT_SHELL"), tokens, ",");
        message << "The calculation of 3rd order anharmonic IFCs will consider up to ";
        message << tokens[0] << " coordination shells." << std::endl;
        if (aaplopts.flag("FOURTH_ORDER")) {
          message << "The calculation of 4th order anharmonic IFCs will consider up to ";
          message << tokens[1] << " coordination shells." << std::endl;
        }
      }

      if (aaplopts.flag("KPPRA")) message << "AAPL will use a KPPRA of " << aaplopts.getattachedscheme("KPPRA") << " for static calculations." << std::endl;

      message << "Anharmonic IFCs will be calculated with a convergence criterion of " << aaplopts.getattachedscheme("SUMRULE") << "." << std::endl;;
      message << "A mixing coefficient of " << aaplopts.getattachedscheme("MIXING_COEFFICIENT")<< " will be used." << std::endl;
      message << "Anharmonic IFCs need to be converged within " << aaplopts.getattachedscheme("SUMRULE_MAX_ITER") << " iterations." << std::endl;

      message << "Thermal conductivity will be calculated between ";
      message << aaplopts.getattachedscheme("TSTART") << " K";
      message << " and " << aaplopts.getattachedscheme("TEND") << "K";
      message << " in " << aaplopts.getattachedscheme("TSTEP") << " K steps." << std::endl;

      message << "The Boltzmann Transport Equation will be solved using ";
      if (aaplopts.getattachedscheme("BTE") == "RTA") {
        message << "the Relaxation Time Approximation Approximation (RTA)." << std::endl;
      } else {
        message << "an iterative scheme." << std::endl;
      }
      message << "The equation will be solved using the tetrahedron method along a ";
      message << aaplopts.getattachedscheme("THERMALGRID") << " q-point mesh." << std::endl;
      message << "Isotope effects will " << (aaplopts.flag("ISOTOPE")?"":"NOT ") << "be included." << std::endl;
      if (aaplopts.flag("BOUNDARY") || aaplopts.flag("CUMULATIVEK")) {
        message << "Boundary effects will be included via ";
        if (aaplopts.flag("BOUNDARY")) {
          message << "boundary scattering with a grain size of ";
        } else {
          message << "cumulative thermal conductivity and a mean free path of at most ";
        }
        message << aaplopts.getattachedscheme("NANO_SIZE") << " nm." << std::endl;
      } else {
        message << "Boundary effects will NOT be included." << std::endl;
      }
    } else {
      USER_TCOND = false;
      message << "Anharmonic force constants and thermal conductivity will NOT be calculated.";
    }
    pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
    //ME20181027 STOP

    if (LDEBUG) std::cerr << function << " DEBUG [1c]" << std::endl;

    // QHA ----------------------------------------------------------------------

    //  //PN QUASI-HARMONIC START
    aurostd::xoption CALCULATE_GRUNEISEN_OPTION; CALCULATE_GRUNEISEN_OPTION.option = false;
    aurostd::xoption CALCULATE_DISPLACEMENTS_OPTION; CALCULATE_DISPLACEMENTS_OPTION.option = false;
    aurostd::xoption CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option = false;
    aurostd::xoption CALCULATE_EOS_OPTION; CALCULATE_EOS_OPTION.option = false;
    aurostd::xoption CALCULATE_EOS_SUBDIRECTORIES_OPTION; CALCULATE_EOS_SUBDIRECTORIES_OPTION.option = false;
    aurostd::xoption EDOS_ACURATE_OPTION; EDOS_ACURATE_OPTION.option = false; //PN20180705
    aurostd::xoption INCLUDE_ELE_OPTION;  INCLUDE_ELE_OPTION.option = false; //PN20180705
    //Anisotropic Gruneisen and EOS //PN20180705
    //in the a-direction //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_A_OPTION; CALCULATE_GRUNEISEN_A_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    aurostd::xoption GP_DISTORTION_OPTION; GP_DISTORTION_OPTION.xscheme = "0.03"; double GP_DISTORTION = 0.03; //PN20180705

    //in the b-direction //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_B_OPTION; CALCULATE_GRUNEISEN_B_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //in the c-direction //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_C_OPTION; CALCULATE_GRUNEISEN_C_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //SC-QHA //PN20180705
    aurostd::xoption CALCULATE_SCQHA_OPTION; CALCULATE_SCQHA_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    //QHA3P option
    aurostd::xoption CALCULATE_QHA3P_OPTION; CALCULATE_QHA3P_OPTION.option = false; //PN20180705

    //Anisotropic SCQHA EOS //PN20180705
    //in the a-direction //PN20180705
    aurostd::xoption CALCULATE_SCQHA_A_OPTION; CALCULATE_SCQHA_A_OPTION.option = false; //PN20180705
    aurostd::xoption SCQHA_DISTORTION_OPTION; SCQHA_DISTORTION_OPTION.xscheme = "3.0"; double SCQHA_DISTORTION = 3.0; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //in the b-direction //PN20180705
    aurostd::xoption CALCULATE_SCQHA_B_OPTION; CALCULATE_SCQHA_B_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //in the c-direction //PN20180705
    aurostd::xoption CALCULATE_SCQHA_C_OPTION; CALCULATE_SCQHA_C_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //QHA3P a direction
    aurostd::xoption CALCULATE_QHA3P_A_OPTION; CALCULATE_QHA3P_A_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_A_SUBDIRECTORIES_OPTION; CALCULATE_QHA3P_A_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_B_OPTION; CALCULATE_QHA3P_B_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_B_SUBDIRECTORIES_OPTION; CALCULATE_QHA3P_B_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_C_OPTION; CALCULATE_QHA3P_C_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_C_SUBDIRECTORIES_OPTION; CALCULATE_QHA3P_C_SUBDIRECTORIES_OPTION.option = false; //PN20180705


    //QHA, QHA3P and SCQHA options initializing from previous options
    CALCULATE_GRUNEISEN_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA;
    CALCULATE_GRUNEISEN_A_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA_A;
    CALCULATE_GRUNEISEN_B_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA_B;
    CALCULATE_GRUNEISEN_C_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA_C;

    CALCULATE_SCQHA_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA;
    CALCULATE_SCQHA_A_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA_A;
    CALCULATE_SCQHA_B_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA_B;
    CALCULATE_SCQHA_C_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA_C;

    CALCULATE_QHA3P_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P;
    CALCULATE_QHA3P_A_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P_A;
    CALCULATE_QHA3P_B_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P_B;
    CALCULATE_QHA3P_C_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P_C;

    // different types of fitting options for EOS calculations
    // (1) BM1 => Murnaghan EOS
    // (2) BM2 => Birch-Murnaghan 3rd-order EOS
    // (3) BM3 => Birch-Murnaghan 4th-order EOS
    //[OBSOLETE PN20180705]aurostd::xoption GP_VOL_DISTORTION_OPTION; GP_VOL_DISTORTION_OPTION.xscheme = "0.03"; double GP_VOL_DISTORTION = 0.03;
    aurostd::xoption USER_PROJECTION_DIR_OPTION; USER_PROJECTION_DIR_OPTION.xscheme = "1:1:1"; vector<double> directions(3, 0); directions[0] = 1; directions[1] = 1; directions[2] = 1;   // 3 Miller indices
    aurostd::xoption CUTOFF_FREQ_OPTION; CUTOFF_FREQ_OPTION.xscheme="1e-5"; double CUTOFF_FREQ = 1e-5;  //in amu
    aurostd::xoption EOS_DISTORTION_RANGE_OPTION; EOS_DISTORTION_RANGE_OPTION.xscheme = "-3:6:1"; double EOS_DISTORTION_START = -3; double EOS_DISTORTION_END = 6; double EOS_DISTORTION_DISTORTION_INC=1; //PN20180705
    aurostd::xoption EOS_STATIC_KPPRA_OPTION; EOS_STATIC_KPPRA_OPTION.xscheme = "10000"; int EOS_STATIC_KPPRA = 10000; //PN20180705
    aurostd::xoption NEDOS_OPTION; NEDOS_OPTION.xscheme = "5000"; int NEDOS = 5000; //PN20180705
    aurostd::xoption FITTING_TYPE_OPTION; FITTING_TYPE_OPTION.xscheme = "BM1"; string FITTING_TYPE = "BM1";
    aurostd::xoption SCQHA_PDIS_T_OPTION; SCQHA_PDIS_T_OPTION.xscheme = "100,400,600"; std::vector<double> scqha_pdis_T; //PN20180705
    //PN QUASI-HARMONIC END

    //PN QUASI-HARMONIC START
    if(!USER_TCOND){
      if(kflags.KBIN_PHONONS_CALCULATION_QHA){
        CALCULATE_GRUNEISEN_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA; //recycle what we parsed earlier
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen parameter will" << ( CALCULATE_GRUNEISEN_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA_A){
        CALCULATE_GRUNEISEN_A_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA_A;
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_A_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen_A parameter will" << ( CALCULATE_GRUNEISEN_A_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA_B){
        CALCULATE_GRUNEISEN_B_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA_B;
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_B_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen_B parameter will" << ( CALCULATE_GRUNEISEN_B_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA_C){
        CALCULATE_GRUNEISEN_C_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA_C;
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_C_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen_C parameter will" << ( CALCULATE_GRUNEISEN_C_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      }

      //QHA, QHA3P and SCQHA INCLUDE ELECTRONIC OPTION
      if(kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C ||
          kflags.KBIN_PHONONS_CALCULATION_SCQHA|| kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        INCLUDE_ELE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "INCLUDE_ELE=" + "|" + _ASTROPT_ + "INCLUDE_ELE="), INCLUDE_ELE_OPTION.option, INCLUDE_ELE_OPTION.xscheme);
        logger << (INCLUDE_ELE_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "INCLUDE_ELE=" << (INCLUDE_ELE_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      }

      //QHA3P and SCQHA temperature dependent phonon dispersion option
      if(kflags.KBIN_PHONONS_CALCULATION_SCQHA|| kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        SCQHA_PDIS_T_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "SCQHA_PDIS_T=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_PDIS_T="), SCQHA_PDIS_T_OPTION.option, SCQHA_PDIS_T_OPTION.xscheme);
        tokens.clear(); scqha_pdis_T.clear();
        aurostd::string2tokens(SCQHA_PDIS_T_OPTION.content_string, tokens, string(" ,"));
        if (tokens.size() == 0) {
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the"+_ASTROPT_+"SCQHA_PDIS_T. Specify as SCQHA_PDIS_T=-100.0, 300.0, 600.0", _INPUT_ILLEGAL_);
        }
        if(tokens.size()!=0){
          for (uint i=0; i<tokens.size(); i++){
            scqha_pdis_T.push_back(aurostd::string2utype<double>(tokens.at(i)));
          }
        }
      }
      //rectifying possible user QHA-input errors
      if(CALCULATE_GRUNEISEN_OPTION.option){
        CALCULATE_SCQHA_A_OPTION.option=false;
        CALCULATE_SCQHA_B_OPTION.option=false;
        CALCULATE_SCQHA_C_OPTION.option=false;
      } else if(CALCULATE_GRUNEISEN_A_OPTION.option){
        CALCULATE_SCQHA_OPTION.option=false;
        CALCULATE_SCQHA_B_OPTION.option=false;
        CALCULATE_SCQHA_C_OPTION.option=false;
      } else if(CALCULATE_GRUNEISEN_B_OPTION.option){
        CALCULATE_SCQHA_OPTION.option=false;
        CALCULATE_SCQHA_A_OPTION.option=false;
        CALCULATE_SCQHA_C_OPTION.option=false;
      } else if(CALCULATE_GRUNEISEN_C_OPTION.option){
        CALCULATE_SCQHA_OPTION.option=false;
        CALCULATE_SCQHA_A_OPTION.option=false;
        CALCULATE_SCQHA_B_OPTION.option=false;
      }

      //Writing to log
      if(kflags.KBIN_PHONONS_CALCULATION_SCQHA){
        logger << (CALCULATE_SCQHA_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA=" << (CALCULATE_SCQHA_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA_A){
        logger << (CALCULATE_SCQHA_A_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_A=" << (CALCULATE_SCQHA_A_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA_B){
        logger << (CALCULATE_SCQHA_B_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_B=" << (CALCULATE_SCQHA_B_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        logger << (CALCULATE_SCQHA_C_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_C=" << (CALCULATE_SCQHA_C_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      }

      //Writing to log
      if(kflags.KBIN_PHONONS_CALCULATION_QHA3P){
        logger << (CALCULATE_QHA3P_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P=" << (CALCULATE_QHA3P_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA3P_A){
        logger << (CALCULATE_QHA3P_A_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P_A=" << (CALCULATE_QHA3P_A_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA3P_B){
        logger << (CALCULATE_QHA3P_B_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P_B=" << (CALCULATE_QHA3P_B_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA3P_C){
        logger << (CALCULATE_QHA3P_C_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P_C=" << (CALCULATE_QHA3P_C_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      }

      if(CALCULATE_SCQHA_OPTION.option || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        SCQHA_DISTORTION_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "SCQHA_DISTORTION=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_DISTORTION="), SCQHA_DISTORTION_OPTION.option, SCQHA_DISTORTION_OPTION.xscheme);
        SCQHA_DISTORTION=SCQHA_DISTORTION_OPTION.content_double;
        if (SCQHA_DISTORTION_OPTION.isentry) {
          tokens.clear();
          aurostd::string2tokens(SCQHA_DISTORTION_OPTION.content_string, tokens, string(" "));
          if (tokens.size() != 1) {
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"SCQHA_DISTORTION. Specify as SCQHA_DISTORTION_OPTION=3.0.", _INPUT_ILLEGAL_);
          }
        }
        logger << (SCQHA_DISTORTION_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "SCQHA_DISTORTION=" << SCQHA_DISTORTION << "." << apl::endl;
      }

      if(CALCULATE_GRUNEISEN_OPTION.option || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C || kflags.KBIN_PHONONS_CALCULATION_SCQHA ||
          kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C || kflags.KBIN_PHONONS_CALCULATION_QHA3P ||
          kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C){

        CUTOFF_FREQ_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "CUTOFF_FREQ=" + "|" + _ASTROPT_APL_OLD_ + "CUTOFF_FREQ="), CUTOFF_FREQ_OPTION.option, CUTOFF_FREQ_OPTION.xscheme); //CO20170601
        CUTOFF_FREQ = CUTOFF_FREQ_OPTION.content_double;
        if (CUTOFF_FREQ_OPTION.isentry) {
          tokens.clear();
          aurostd::string2tokens(CUTOFF_FREQ_OPTION.content_string, tokens, string(" "));
          if (tokens.size() != 1) {
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"CUTOFF_FREQ. Specify as CUTOFF_FREQ=0.01.", _INPUT_ILLEGAL_);
          }
        }
        logger << (CUTOFF_FREQ_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "CUTOFF_FREQ=" << CUTOFF_FREQ_OPTION.content_string << "." << apl::endl;


        CALCULATE_EOS_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "EOS=" + "|" + _ASTROPT_APL_OLD_ + "EOS="), CALCULATE_EOS_OPTION.option, CALCULATE_EOS_OPTION.xscheme); //CO20170601
        logger << (CALCULATE_EOS_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "EOS=" << (CALCULATE_EOS_OPTION.option ? "ON" : "OFF") << "." << apl::endl;

        if ((CALCULATE_EOS_OPTION.option) && (CALCULATE_GRUNEISEN_OPTION.option || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B ||
              kflags.KBIN_PHONONS_CALCULATION_QHA_C || kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A ||
              kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C || kflags.KBIN_PHONONS_CALCULATION_QHA3P ||
              kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C))

        {
          EOS_DISTORTION_RANGE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "EOS_DISTORTION_RANGE=" + "|" + _ASTROPT_APL_OLD_ + "EOS_DISTORTION_RANGE="), EOS_DISTORTION_RANGE_OPTION.option, EOS_DISTORTION_RANGE_OPTION.xscheme);
          tokens.clear();
          aurostd::string2tokens(EOS_DISTORTION_RANGE_OPTION.content_string, tokens, string(" :"));
          if (tokens.size() != 3) {
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"EOS_DISTORTION_RANGE. Specify as EOS_DISTORTION_RANGE=-3:6:1.", _INPUT_ILLEGAL_);
          }
          EOS_DISTORTION_START = aurostd::string2utype<double>(tokens.at(0));
          EOS_DISTORTION_END = aurostd::string2utype<double>(tokens.at(1));
          EOS_DISTORTION_DISTORTION_INC = aurostd::string2utype<double>(tokens.at(2));
          logger << (EOS_DISTORTION_RANGE_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "EOS_DISTORTION_RANGE=" << EOS_DISTORTION_RANGE_OPTION.content_string << "." << apl::endl;
          logger << "The EOS properties will be calculated in distortion range <" << EOS_DISTORTION_START << "," << EOS_DISTORTION_END << "," << EOS_DISTORTION_DISTORTION_INC << "." << apl::endl;

          FITTING_TYPE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "FITTING_TYPE=" + "|" + _ASTROPT_APL_OLD_ + "FITTING_TYPE="), FITTING_TYPE_OPTION.option, FITTING_TYPE_OPTION.xscheme); //CO20170601
          FITTING_TYPE = FITTING_TYPE_OPTION.content_string;
          if (FITTING_TYPE_OPTION.isentry) {
            tokens.clear();
            aurostd::string2tokens(FITTING_TYPE_OPTION.content_string, tokens, string(" "));
            if (tokens.size() != 1) {
              throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"FITTING_TYPE. Specify as FITTING_TYPE=BM2.", _INPUT_ILLEGAL_);
            }
          }
          logger << (FITTING_TYPE_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "FITTING_TYPE=" << FITTING_TYPE_OPTION.content_string << "." << apl::endl;
          logger << "EOS fitting type found = " << FITTING_TYPE << "." << apl::endl;

          EOS_STATIC_KPPRA_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "EOS_STATIC_KPPRA=" + "|" + _ASTROPT_APL_OLD_ + "EOS_STATIC_KPPRA="), EOS_STATIC_KPPRA_OPTION.option, EOS_STATIC_KPPRA_OPTION.xscheme);
          EOS_STATIC_KPPRA = EOS_STATIC_KPPRA_OPTION.content_int;
          if(CALCULATE_GRUNEISEN_OPTION.option){
            if (EOS_STATIC_KPPRA_OPTION.isentry) {
              tokens.clear();
              aurostd::string2tokens(EOS_STATIC_KPPRA_OPTION.content_string, tokens, string(" "));
              if (tokens.size() != 1) {
                throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"EOS_STATIC_KPPRA. Specify as EOS_STATIC_KPPRA=10000.", _INPUT_ILLEGAL_);
              }
            }
            logger << (EOS_STATIC_KPPRA_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "EOS_STATIC_KPPRA=" << EOS_STATIC_KPPRA_OPTION.content_string << "." << apl::endl;
          }
          NEDOS_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "NEDOS=" + "|" + _ASTROPT_APL_OLD_ + "NEDOS="), NEDOS_OPTION.option, NEDOS_OPTION.xscheme);
          NEDOS = NEDOS_OPTION.content_int;
          if (NEDOS_OPTION.isentry) {
            tokens.clear();
            aurostd::string2tokens(NEDOS_OPTION.content_string, tokens, string(" "));
            if (tokens.size() != 1) {
              throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"NEDOS. Specify as NEDOS=5000.", _INPUT_ILLEGAL_);
            }
          }
          logger << (NEDOS_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "NEDOS=" << NEDOS_OPTION.content_string << "." << apl::endl;
        }
      }
    }
    //GP SUBDIRECTORY OPTIONS. These are automic options and not controlled by users
    CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_SD="), CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.xscheme);
    if(!CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option){
      CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_A_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_A_SD="), CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.xscheme);
      if(!CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option){
        CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_B_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_B_SD="), CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.xscheme);
        if(!CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option){
          CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_C_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_C_SD="), CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.xscheme);
        }
      }
    }

    //Writing to log
    if(CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_SD=" << (CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_A_SD=" << (CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_B_SD=" << (CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_C_SD=" << (CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    }

    if(CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option|| CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option || CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option || CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option){
      GP_DISTORTION_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "GP_DISTORTION=" + "|" + _ASTROPT_APL_OLD_ + "GP_DISTORTION="), GP_DISTORTION_OPTION.option, GP_DISTORTION_OPTION.xscheme);
      GP_DISTORTION=GP_DISTORTION_OPTION.content_double;
      if (GP_DISTORTION_OPTION.isentry) {
        tokens.clear();
        aurostd::string2tokens(GP_DISTORTION_OPTION.content_string, tokens, string(" "));
        if (tokens.size() != 1) {
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"GP_DISTORTION. Specify as GP_DISTORTION=0.03.", _INPUT_ILLEGAL_);
        }
      }
      logger << (GP_DISTORTION_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GP_DISTORTION=" << GP_DISTORTION << "." << apl::endl;
    }
    //EOS SUBDIRECTORY OPTIONS. These are automic options and not controlled by users
    CALCULATE_EOS_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "EOS_SD=" + "|" + _ASTROPT_APL_OLD_ + "EOS_SD="), CALCULATE_EOS_SUBDIRECTORIES_OPTION.option, CALCULATE_EOS_SUBDIRECTORIES_OPTION.xscheme); //CO20170601
    if(CALCULATE_EOS_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_EOS_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "EOS_SD=" << (CALCULATE_EOS_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      EOS_DISTORTION_RANGE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "EOS_DISTORTION_RANGE=" + "|" + _ASTROPT_APL_OLD_ + "EOS_DISTORTION_RANGE="), EOS_DISTORTION_RANGE_OPTION.option, EOS_DISTORTION_RANGE_OPTION.xscheme); //CO20170601
      tokens.clear();
      aurostd::string2tokens(EOS_DISTORTION_RANGE_OPTION.content_string, tokens, string(" :"));
      if (tokens.size() != 3) {
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"EOS_DISTORTION_RANGE. Specify as EOS_DISTORTION_RANGE=-3:6:1", _INPUT_ILLEGAL_);
      }
      EOS_DISTORTION_START = aurostd::string2utype<double>(tokens.at(0));
      EOS_DISTORTION_END = aurostd::string2utype<double>(tokens.at(1));
      EOS_DISTORTION_DISTORTION_INC = aurostd::string2utype<double>(tokens.at(2));
      logger << (EOS_DISTORTION_RANGE_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "EOS_DISTORTION_RANGE=" << EOS_DISTORTION_RANGE_OPTION.content_string << "." << apl::endl;
      logger << "The EOS properties will be calculated in distortion range <" << EOS_DISTORTION_START << "," << EOS_DISTORTION_END << "," << EOS_DISTORTION_DISTORTION_INC << "." << apl::endl;
    }

    //SCQHA SUBDIRECTORY OPTIONS. These are automic options and not controlled by users
    CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_SD="), CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.xscheme);
    if(!CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option){
      CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_A_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_A_SD="), CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.xscheme);
      if(!CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option){
        CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_B_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_B_SD="), CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.xscheme);
        if(!CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option){
          CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_C_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_C_SD="), CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.xscheme);
        }
      }
    }

    //Writing to log
    if(CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_SD=" << (CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_A_SD=" << (CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_B_SD=" << (CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_C_SD=" << (CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    }

    if(CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option || CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option || CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option || CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.isentry){
      SCQHA_DISTORTION_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "SCQHA_DISTORTION=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_DISTORTION="), SCQHA_DISTORTION_OPTION.option, SCQHA_DISTORTION_OPTION.xscheme);
      SCQHA_DISTORTION=SCQHA_DISTORTION_OPTION.content_double;
      if (SCQHA_DISTORTION_OPTION.isentry) {
        tokens.clear();
        aurostd::string2tokens(SCQHA_DISTORTION_OPTION.content_string, tokens, string(" "));
        if (tokens.size() != 1) {
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"SCQHA_DISTORTION. Specify as SCQHA_DISTORTION=3.0.", _INPUT_ILLEGAL_);
        }
      }
      logger << (SCQHA_DISTORTION_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "SCQHA_DISTORTION=" << SCQHA_DISTORTION << "." << apl::endl;
    }
    //PN QUASI-HARMONIC END

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                          PREPARE CALCULATIONS                           //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << function << " DEBUG [2]" << std::endl;

    //fix vasp bin for LR or DM+POLAR
    if (aplopts.getattachedscheme("ENGINE") == "LR" || (aplopts.getattachedscheme("ENGINE") == string("DM") && aplopts.flag("POLAR"))) {
      if(xflags.AFLOW_MODE_VASP && !XHOST.GENERATE_AFLOWIN_ONLY){  //ME20190313 - Do not check the VASP binary for generate_aflowin_only
        try {
          // Check the version of VASP binary
          message << "Checking VASP version for linear response calculations.";
          string vaspVersion;
          vaspVersion = getVASPVersionString( (kflags.KBIN_MPI ? kflags.KBIN_MPI_BIN : kflags.KBIN_BIN ) );
          if (!vaspVersion.empty()) {
            message << "[" << vaspVersion[0] << "].";
            if ((vaspVersion[0] - '0') < 5) { //cool way of getting ascii value:  https://stackoverflow.com/questions/36310181/char-subtraction-in-c
              pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
              //ME20190107 - fix both serial and MPI binaries
              kflags.KBIN_SERIAL_BIN = DEFAULT_VASP5_BIN;
              kflags.KBIN_MPI_BIN = DEFAULT_VASP5_MPI_BIN;
              if (kflags.KBIN_MPI) {
                kflags.KBIN_BIN = kflags.KBIN_MPI_BIN;
              } else {
                kflags.KBIN_BIN = kflags.KBIN_SERIAL_BIN;
              }
              message << "Modifying VASP bin to " << kflags.KBIN_BIN << " (AUTO modification).";  //ME20190109
              pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
            } else {
              message << " OK.";
              pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
            }
          } else {
            message << "Failed.";
            pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Unexpected binary format.", _FILE_WRONG_FORMAT_);
          }
        } catch (aurostd::xerror& excpt) {
          message << "Failed to identify the version of the VASP binary." << std::endl;
          message << excpt.error_message << std::endl;
          pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
        }
      }
    }

    //ME20200102 BEGIN
    // The PHPOSCAR file now also serves as the canonical structure
    // for the phonon calculations. This prevents any changes in symmetry codes,
    // especially the structure conversion codes, from changing the structure
    // between AFLOW versions.
    string phposcar_file = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_PHPOSCAR_FILE);
    if (aurostd::EFileExist(phposcar_file)) {
      message << "Reading structure from file " << phposcar_file << ".";
      pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      xinput.getXStr() = xstructure(phposcar_file, IOVASP_POSCAR);
    }

    // Set up the phonon calculator
    apl::PhononCalculator phcalc(messageFile, oss);
    if (xflags.vflags.AFLOW_SYSTEM.content_string.empty()) {
      phcalc._system = xinput.getXStr().title;
    } else {
      phcalc._system = xflags.vflags.AFLOW_SYSTEM.content_string;
    }
    phcalc.setDirectory(aflags.Directory);
    phcalc.setNCPUs(kflags);
    phcalc.setPolarMaterial(aplopts.flag("POLAR"));
    phcalc.initialize_supercell(xinput.getXStr());
    apl::Supercell& supercell = phcalc.getSupercell();

    // Determine the supercell dimensions
    xvector<int> scell_dims = supercell.determineSupercellDimensions(aplopts);

    // Don't relax when we already have a PHPOSCAR file (state saved)
    if (!aurostd::EFileExist(phposcar_file) && aplopts.flag("RELAX")) {
      //ME20190107 - Relax after fixing the vasp bin to make version consistent.
      // Run relaxations if necessary
      bool Krun=true;
      string function;
      if (xinput.AFLOW_MODE_VASP) {
        function = "KBIN::relaxStructureAPL_VASP";
        Krun = relaxStructureAPL_VASP(START_RELAX, AflowIn, aplopts, scell_dims,
            aplopts.flag("COMMENSURATE"), xinput.xvasp, aflags, kflags, xflags.vflags, messageFile);
      }
      if (!Krun) {
        message << "Relaxation calculations did not run successfully.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_,function, message, _RUNTIME_ERROR_);
      }

      // Reinitialize the supercell with the new structure
      supercell.initialize(xinput.getXStr());
    }

    // Build after relaxations are done
    supercell.build(scell_dims);
    if (USER_MAXSHELL > 0) supercell.setupShellRestrictions(USER_MAXSHELL);

    //ME20200427 - If NBANDS has been specified, store the number of supercells
    // to scale.
    if (xflags.vflags.KBIN_VASP_FORCE_OPTION_NBANDS_EQUAL.isentry) {
      int ncells = scell_dims[1] * scell_dims[2] * scell_dims[3];
      xinput.xvasp.aopts.push_attached("AFLOW_APL::NCELLS", aurostd::utype2string<int>(ncells));
    }

    // Write supercell input structure into PHPOSCAR to save state
    // unless it has been read before.
    if (!aurostd::EFileExist(phposcar_file)) {
      xstructure xstr = supercell.getInputStructureLight();
      xstr.is_vasp5_poscar_format = true;
      stringstream poscar;
      poscar << xstr;
      aurostd::stringstream2file(poscar, phposcar_file);
      if (!aurostd::FileExist(phposcar_file)) {
        message << "Cannot open output file " << phposcar_file << ".";
        throw aurostd::xerror(_AFLOW_FILE_NAME_,function, message, _FILE_ERROR_);
      }
    }
    //ME20200102 END

    //ME20190626 - Convert projection directions for DOS to Cartesian
    if ((USER_DOS_PROJECTIONS.size() > 0) && aplopts.flag("DOS_FRAC")) {
      for (uint p = 0; p < USER_DOS_PROJECTIONS.size(); p++) {
        USER_DOS_PROJECTIONS[p] = xinput.getXStr().f2c * USER_DOS_PROJECTIONS[p];
      }
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           QHA                                           //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    //AS20200513 BEGIN
    bool run_any_qha =
      kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C ||
      kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C ||
      kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C;
    if (NEW_QHA && run_any_qha){
      // ME20200516 - APL options are recast into xoption now, so no need to
      // distinguish between supercell_opts, aplopts, and qha.apl_options.
      string USER_TPT = aplopts.getattachedscheme("TPT");
      apl::QHAN qha(USER_TPT, xinput, kflags, aplopts, messageFile, oss);
      //[OBSOLETE] qha.apl_options = aplopts;
      //[OBSOLETE] qha.apl_options.push_attached("ENGINE", USER_ENGINE);
      //[OBSOLETE] qha.apl_options.flag("AUTO_DIST", USER_AUTO_DISTORTIONS);
      //[OBSOLETE] qha.apl_options.flag("DPM", USER_DPM);
      //[OBSOLETE] qha.apl_options.flag("XYZONLY", USER_DISTORTIONS_XYZ_ONLY);
      //[OBSOLETE] qha.apl_options.flag("SYMMETRIZE", USER_DISTORTIONS_SYMMETRIZE);
      //[OBSOLETE] qha.apl_options.flag("INEQUIVONLY", USER_DISTORTIONS_INEQUIVONLY);
      //[OBSOLETE] qha.apl_options.flag("ZEROSTATE", USER_ZEROSTATE);
      //[OBSOLETE] qha.apl_options.flag("POLAR", USER_POLAR);
      //[OBSOLETE] qha.apl_options.push_attached("DIST_MAGNITUDE",
      //[OBSOLETE]     aurostd::utype2string<double>(USER_DISTORTION_MAGNITUDE));

      //[OBSOLETE] qha.apl_options.push_attached("DOS_METHOD", USER_DOS_METHOD);
      //[OBSOLETE] qha.apl_options.push_attached("DOS_MESH", DOS_MESH_SCHEME);
      //[OBSOLETE] qha.apl_options.push_attached("DOS_NPOINTS",
      //[OBSOLETE]     aurostd::utype2string<int>(USER_DOS_NPOINTS));
      //[OBSOLETE] qha.apl_options.push_attached("DOS_SMEAR",
      //[OBSOLETE]     aurostd::utype2string<double>(USER_DOS_SMEAR));
      //[OBSOLETE] qha.apl_options.push_attached("DOS_NPOINTS",
      //[OBSOLETE]     aurostd::utype2string<int>(USER_DOS_NPOINTS));
      //[OBSOLETE] qha.apl_options.push_attached("BAND_NPOINTS",
      //[OBSOLETE]     aurostd::utype2string<int>(USER_DC_NPOINTS));

      qha.system_title = phcalc._system;
      qha.run(xflags, aflags, kflags, AflowIn);
      return;
    }
    //AS20200513 END

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           CALCULATE PHONONS                             //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    // FORCE CONSTANTS ----------------------------------------------------------
    bool stagebreak = false;

    // Harmonic force constants
    string hibfile = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_HARMIFC_FILE);
    bool awakeHarmIFCs = (aplopts.flag("HIBERNATE") && aurostd::EFileExist(hibfile));
    bool apl_stagebreak = false;
    // Try to read first
    if (awakeHarmIFCs) {
      try {
        pflow::logger(_AFLOW_FILE_NAME_, "APL", "Awakening...", aflags, messageFile, oss);
        phcalc.awake();
      } catch (aurostd::xerror& e) {
        message << e.error_message + " Skipping awakening...";
        pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss, _LOGGER_WARNING_);
        awakeHarmIFCs = false;
      }
    }

    // Reading failed - calculate
    if (!awakeHarmIFCs) {
      // Set up calculator
      apl::ForceConstantCalculator fccalc(supercell, aplopts, messageFile, oss);
      apl_stagebreak = fccalc.runVASPCalculations(xinput, aflags, kflags, xflags, AflowIn);
      fccalc.saveState(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_STATE_FILE);
      if (!apl_stagebreak) {
        apl_stagebreak = !(fccalc.run());
        if (!apl_stagebreak) {
          if (aplopts.flag("HIBERNATE")) fccalc.hibernate();
          phcalc.setHarmonicForceConstants(fccalc);
        }
      }
    }

    if (LDEBUG) std::cerr << function << " DEBUG [3b]" << std::endl;

    stagebreak = (stagebreak || apl_stagebreak);

    //QHA/SCQHA/QHA3P  START //PN20180705
    // Create directories for QHA/SCQHA/QHA3P
    // The pointer pheos should be called before creation of apl.xml
    auto_ptr<apl::QHA_AFLOWIN_CREATOR> pheos;
    if(CALCULATE_GRUNEISEN_OPTION.option || CALCULATE_GRUNEISEN_A_OPTION.option || CALCULATE_GRUNEISEN_B_OPTION.option || CALCULATE_GRUNEISEN_C_OPTION.option ||
        CALCULATE_SCQHA_OPTION.option || CALCULATE_SCQHA_A_OPTION.option || CALCULATE_SCQHA_B_OPTION.option || CALCULATE_SCQHA_C_OPTION.option ||
        CALCULATE_QHA3P_OPTION.option || CALCULATE_QHA3P_A_OPTION.option || CALCULATE_QHA3P_B_OPTION.option || CALCULATE_QHA3P_C_OPTION.option)
    {
      pheos.reset(new apl::QHA_AFLOWIN_CREATOR(supercell, messageFile, oss));

      pheos->setGP(CALCULATE_GRUNEISEN_OPTION.option, CALCULATE_GRUNEISEN_A_OPTION.option, CALCULATE_GRUNEISEN_B_OPTION.option, CALCULATE_GRUNEISEN_C_OPTION.option);
      if( CALCULATE_SCQHA_OPTION.option || CALCULATE_SCQHA_A_OPTION.option || CALCULATE_SCQHA_B_OPTION.option || CALCULATE_SCQHA_C_OPTION.option )
      {
        pheos->setSCGP(CALCULATE_SCQHA_OPTION.option, CALCULATE_SCQHA_A_OPTION.option, CALCULATE_SCQHA_B_OPTION.option, CALCULATE_SCQHA_C_OPTION.option);
      }
      if( CALCULATE_QHA3P_OPTION.option || CALCULATE_QHA3P_A_OPTION.option || CALCULATE_QHA3P_B_OPTION.option || CALCULATE_QHA3P_C_OPTION.option )
      {
        pheos->setSCGP(CALCULATE_QHA3P_OPTION.option, CALCULATE_QHA3P_A_OPTION.option, CALCULATE_QHA3P_B_OPTION.option, CALCULATE_QHA3P_C_OPTION.option);
      }

      pheos->setGP_VOL_DISTORTION(GP_DISTORTION);
      if(CALCULATE_SCQHA_OPTION.option || CALCULATE_SCQHA_A_OPTION.option || CALCULATE_SCQHA_B_OPTION.option || CALCULATE_SCQHA_C_OPTION.option ||
          CALCULATE_QHA3P_OPTION.option || CALCULATE_QHA3P_A_OPTION.option || CALCULATE_QHA3P_B_OPTION.option|| CALCULATE_QHA3P_C_OPTION.option){
        pheos->setSCGP_VOL_DISTORTION(SCQHA_DISTORTION);
      }
      if(CALCULATE_EOS_OPTION.option){
        pheos->setEOS(CALCULATE_EOS_OPTION.option);
        pheos->setEOS_distortion_range(EOS_DISTORTION_START, EOS_DISTORTION_END, EOS_DISTORTION_DISTORTION_INC);
        pheos->setEOS_STATIC_KPPRA(EOS_STATIC_KPPRA);
        pheos->setEOS_NEDOS(NEDOS);
        pheos->set_edos_accurate(EDOS_ACURATE_OPTION.option);
      }
      pheos->run_qha(xinput, kflags, xflags);
      pheos->close_log();
    }
    //QHA/SCQHA/QHA3P END

    if (LDEBUG) std::cerr << function << " DEBUG [3c]" << std::endl;

    // Anharmonic force constants
    bool aapl_stagebreak = false;
    if (USER_TCOND) {
      int max_order = (aaplopts.flag("FOURTH_ORDER") ? 4 : 3);
      for (int o = 3; o <= max_order; o++) {
        // Try and load IFCs from file
        string ifcs_hib_file = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_AAPL_FILE_PREFIX + _ANHARMONIC_IFCS_FILE_[o-3]);
        bool awakeAnharmIFCs = (aplopts.flag("HIBERNATE") && aurostd::EFileExist(ifcs_hib_file));
        if (awakeAnharmIFCs) {
          try {
            message << "Reading anharmonic IFCs from " + ifcs_hib_file + ".";
            pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
            phcalc.readAnharmonicIFCs(ifcs_hib_file);
          } catch (aurostd::xerror& excpt) {
            message<< excpt.error_message + " Skipping awakening of ";
            if (o == 3) message << "3rd";
            else message << aurostd::utype2string<int>(o) + "th";
            message << excpt.error_message + " order anharmonic IFCs.";
            pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
            awakeAnharmIFCs = false;
          }
        }

        // Reading failed - calculate
        if (!awakeAnharmIFCs) {
          // Setup calculations
          apl::AnharmonicIFCs anharm(messageFile, oss);
          anharm.setDirectory(aflags.Directory);
          anharm.initialize(phcalc.getSupercell(), o, aaplopts);
          aapl_stagebreak = (anharm.runVASPCalculations(xinput, aflags, kflags, xflags) || aapl_stagebreak);
          // Calculate IFCs
          if (!aapl_stagebreak) {
            aapl_stagebreak = !(anharm.calculateForceConstants());
            if (!aapl_stagebreak) {
              if (aplopts.flag("HIBERNATE")) anharm.writeIFCsToFile(ifcs_hib_file);
              phcalc.setAnharmonicForceConstants(anharm);
            }
          }
        }
      }
    }
    //ME201901029 BEGIN
    stagebreak = (stagebreak || aapl_stagebreak);

    // At least one calculation has not finished - return
    if (stagebreak) {
      message << "Stopped. Waiting for required calculations...";  //CO20181226
      pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_NOTICE_);
      return;
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                            QUASI-HARMONIC                               //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << function << " DEBUG [4]" << std::endl;

    //QHA/SCQHA/QHA3P START //PN20180705
    //Store dynamical matrices and PDOS from different distorted directores
    if(CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option)
    { 
      apl::QHAsubdirectoryData store(phcalc, logger);
      store.setdir_prefix(_TMPDIR_);
      string dirname = store.getdir_name(aflags.Directory);
      store.set_gp_vol_distortion(GP_DISTORTION);
      //create uniform q-mesh
      store.createMPmesh(USER_DOS_MESH[0], USER_DOS_MESH[1], USER_DOS_MESH[2],
          phcalc.getInputCellStructure());

      //check the distorted directort contains Gruneisen ON //PN20180705
      if(store.check_GP()){ //PN20180705
        //store dynamical matrices //PN20180705
        store.create_dm(); //PN20180705
        apl::PhononDispersionCalculator pdisc(phcalc);

        // Init path according to the aflow's definition for elec. struc.
        //ME20181029 - Restructured
        if (aplopts.getattachedscheme("DCPATH") == "LATTICE") {
          pdisc.initPathLattice("", aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")));
        } else {
          pdisc.initPathCoords(aplopts.getattachedscheme("DCINITCOORDS"),
            aplopts.getattachedscheme("DCINITCOORDSLABELS"),
            aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")), aplopts.flag("DCCORDS_CART"));
        }
        //ME20190501 Allow user to override path
        string USER_DC_USERPATH = aplopts.getattachedscheme("DCUSERPATH");
        if(!USER_DC_USERPATH.empty()){  // Set path
          pdisc.setPath(USER_DC_USERPATH);
        }

        std::vector<xvector<double> > qpoints = pdisc.get_qpoints();
        //store dynamical matrices along path //PN20180705
        store.create_pdispath(qpoints);
        qpoints.clear();
      }
      store.clear(); //PN20180705
      return; //PN20180705
    } //PN20180705
    //store PDOS from different distorted directories
    if(CALCULATE_EOS_SUBDIRECTORIES_OPTION.option)
    {
      apl::QHAsubdirectoryData store(phcalc, logger);
      store.setdir_prefix(_TMPDIR_);
      string dirname=store.getdir_name(aflags.Directory);

      if (!phcalc.getQMesh().initialized()) phcalc.initialize_qmesh(USER_DOS_MESH);
      apl::DOSCalculator dosc(phcalc, aplopts.getattachedscheme("DOS_METHOD"), USER_DOS_PROJECTIONS);
      // Calculate DOS
      dosc.calc(aurostd::string2utype<int>(aplopts.getattachedscheme("DOSPOINTS")), aurostd::string2utype<double>(aplopts.getattachedscheme("DOSSMEAR")));
      if (aplopts.flag("DOS")) dosc.writePDOS(_TMPDIR_, dirname);
      store.clear();
      return;
    }
    //SCQHA and QHA3P save dynamical matrices and PDOS from different distorted directories
    if(CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option)
    {
      {
        apl::QHAsubdirectoryData store(phcalc, logger);
        store.setdir_prefix(_TMPDIR_);
        string dirname=store.getdir_name(aflags.Directory);
        store.set_sc_vol_distortion(SCQHA_DISTORTION);

        //create uniform q-mesh
        store.createMPmesh(USER_DOS_MESH[0], USER_DOS_MESH[1], USER_DOS_MESH[2],
            phcalc.getInputCellStructure());

        if(store.check_SCQHA())
        {
          store.create_dm();
          apl::PhononDispersionCalculator pdisc(phcalc);

          // Init path according to the aflow's definition for elec. struc.
          //ME20181029 - Restructured
          if (aplopts.getattachedscheme("DCPATH") == "LATTICE") {
            pdisc.initPathLattice("", aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")));
          } else {
            pdisc.initPathCoords(aplopts.getattachedscheme("DCINITCOORDS"),
              aplopts.getattachedscheme("DCINITCOORDSLABELS"),
              aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")), aplopts.flag("DCCORDS_CART"));
          }
          //ME20190501 Allow user to override path
          string USER_DC_USERPATH = aplopts.getattachedscheme("DCUSERPATH");
          if(!USER_DC_USERPATH.empty()){  // Set path
            pdisc.setPath(USER_DC_USERPATH);
          }

          std::vector< xvector<double> > qpoints=pdisc.get_qpoints();
          store.create_pdispath(qpoints);
          qpoints.clear();
        }
        {
          if (!phcalc.getQMesh().initialized()) phcalc.initialize_qmesh(USER_DOS_MESH);
          apl::DOSCalculator dosc(phcalc, aplopts.getattachedscheme("DOS_METHOD"), USER_DOS_PROJECTIONS);
          // Calculate DOS
          dosc.calc(aurostd::string2utype<int>(aplopts.getattachedscheme("DOSPOINTS")), aurostd::string2utype<double>(aplopts.getattachedscheme("DOSSMEAR")));
          if(aplopts.flag("DOS"))dosc.writePDOS(_TMPDIR_, dirname);
        }
        store.clear();
      }
      return;
    }
    //PN QHA/SCQHA/QHA3P  END

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           PHONON PROPERTIES                             //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    // Get the format of frequency desired by user ///////////////////////

    if (LDEBUG) std::cerr << function << " DEBUG [5a]" << std::endl;

    apl::IPCFreqFlags frequencyFormat = apl::NONE;

    string USER_FREQFORMAT = aplopts.getattachedscheme("FREQFORMAT");
    if (!USER_FREQFORMAT.empty()) {
      // Convert format to machine representation
      tokens.clear();
      aurostd::string2tokens(USER_FREQFORMAT, tokens, string(" |:;,"));
      for (uint i = 0; i < tokens.size(); i++) {
        if (tokens.at(i) == string("OMEGA")) {
          frequencyFormat |= apl::OMEGA;
          continue;
        }
        if (tokens.at(i) == string("HERTZ")) {
          frequencyFormat |= apl::HERTZ;
          continue;
        } else if (tokens.at(i) == string("THZ")) {
          frequencyFormat |= apl::THZ;
          continue;
        } else if (tokens.at(i) == string("CM-1") || tokens.at(i) == string("RECIPROCAL_CM")) {
          frequencyFormat |= apl::RECIPROCAL_CM;
          continue;
        } else if (tokens.at(i) == string("MEV")) {
          frequencyFormat |= apl::MEV;
          continue;
        }
        if (tokens.at(i) == string("ALLOW_NEGATIVE")) {
          frequencyFormat |= apl::ALLOW_NEGATIVE;
          continue;
        }
      }
      // Check if there was specified unit keyword...
      if (((frequencyFormat & ~apl::OMEGA) & ~apl::ALLOW_NEGATIVE) == apl::NONE)
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Ambiguous frequency format.", _INPUT_AMBIGUOUS_);
    } else {
      frequencyFormat = apl::THZ | apl::ALLOW_NEGATIVE;
    }

    //high-symmery qpoint auto pointer [PN] //PN20180705
    auto_ptr<apl::PhononHSQpoints> ptr_hsq;
    bool is_negative_freq=false;
    bool scqha_is_vol_err=false;
    //high-symmery qpoint auto pointer END [PN]

    // PHONON DISPERSIONS ---------------------------------------------------------

    if (LDEBUG) std::cerr << function << " DEBUG [5b]" << std::endl;

    if (aplopts.flag("DC")) {
      apl::PhononDispersionCalculator pdisc(phcalc);

      // Init path according to the aflow's definition for elec. struc.
      //ME20181029 - Restructured
      if (aplopts.getattachedscheme("DCPATH") == "LATTICE") {
        if (!supercell.projectToPrimitive()) {  //ME20200117 - project to primitive
          message << "Could not map the AFLOW standard primitive cell to the supercell.";
          message << " Phonon dispersions will be calculated using the original structure instead.";
          pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss, _LOGGER_WARNING_);
        }
        pdisc.initPathLattice("", aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")));
      } else {
        pdisc.initPathCoords(aplopts.getattachedscheme("DCINITCOORDS"),
          aplopts.getattachedscheme("DCINITCOORDSLABELS"),
          aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")), aplopts.flag("DCCORDS_CART"));
      }
      //ME20190501 Allow user to override path
      string USER_DC_USERPATH = aplopts.getattachedscheme("DCUSERPATH");
      if(!USER_DC_USERPATH.empty()){  // Set path
        pdisc.setPath(USER_DC_USERPATH);
      }

      // Calculate frequencies on path
      pdisc.calc(frequencyFormat);

      // Write results into PDIS file
      pdisc.writePDIS(aflags.Directory);
      pdisc.writePHEIGENVAL(aflags.Directory);  //ME20190614
      if (aplopts.getattachedscheme("DCPATH") == "LATTICE") supercell.projectToOriginal();  //ME20200117 - reset to original
      //QHA/SCQHA/QHA3P  START //PN20180705
      //////////////////////////////////////////////////////////////////////
      ptr_hsq.reset(new apl::PhononHSQpoints(logger));
      ptr_hsq->read_qpointfile(aflags.Directory);
      //compute Gruneisen dispersion curve
      if (CALCULATE_GRUNEISEN_OPTION.option ||
          CALCULATE_GRUNEISEN_A_OPTION.option ||
          CALCULATE_GRUNEISEN_B_OPTION.option ||
          CALCULATE_GRUNEISEN_C_OPTION.option)
      {
        apl::QHA qha(phcalc, *pheos, logger);
        qha.get_tmp_dir_name(_TMPDIR_);
        qha.set_cutoff_freq(CUTOFF_FREQ);
        if(qha.set_imported_variables())
        {
          if(qha.calculation_gruneisen(ptr_hsq->get_qpoints()))
          {
            qha.write_gruneisen_parameter_path(ptr_hsq->get_path(), ptr_hsq->get_path_segment());
            is_negative_freq=qha.get_is_negative_freq();
          }
        }
        qha.clear();
      }
      //QHA/SCQHA/QHA3P  END
    }

    // PHONON DOS AND THERMODYNAMIC PROPERTIES ----------------------------------------

    if (LDEBUG) std::cerr << function << " DEBUG [5c]" << std::endl;

    if (aplopts.flag("DOS") || aplopts.flag("TP")) {
      // Calculate DOS
      if (!phcalc.getQMesh().initialized()) phcalc.initialize_qmesh(USER_DOS_MESH);
      apl::DOSCalculator dosc(phcalc, aplopts.getattachedscheme("DOS_METHOD"), USER_DOS_PROJECTIONS);
      dosc.calc(aurostd::string2utype<int>(aplopts.getattachedscheme("DOSPOINTS")), aurostd::string2utype<double>(aplopts.getattachedscheme("DOSSMEAR")));
      if (aplopts.flag("DOS")) {
        dosc.writePDOS(aflags.Directory);
        dosc.writePHDOSCAR(aflags.Directory);  //ME20190614
      }

      // Calculate thermal properties
      if (aplopts.flag("TP")) {
        //if (!dosc.hasNegativeFrequencies()) //ME20200210 - Do not skip, just ignore contributions of imaginary frequencies and throw a warning
        apl::ThermalPropertiesCalculator tpc(dosc, messageFile, aflags.Directory, oss);  //ME20190423
        //ME20200108 - new ThermalPropertiesCalculator format
        double USER_TP_TSTART = aurostd::string2utype<double>(aplopts.getattachedscheme("TSTART"));
        double USER_TP_TEND = aurostd::string2utype<double>(aplopts.getattachedscheme("TEND"));
        double USER_TP_TSTEP = aurostd::string2utype<double>(aplopts.getattachedscheme("TSTEP"));
        tpc.calculateThermalProperties(USER_TP_TSTART, USER_TP_TEND, USER_TP_TSTEP);
        tpc.writePropertiesToFile(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_THERMO_FILE);

        if (aplopts.flag("DISPLACEMENTS")) {
          apl::AtomicDisplacements ad(phcalc);
          ad.calculateMeanSquareDisplacements(USER_TP_TSTART, USER_TP_TEND, USER_TP_TSTEP);
          ad.writeMeanSquareDisplacementsToFile(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_MSQRDISP_FILE);
        }

        if (aplopts.flag("GROUP_VELOCITY")) {
          string gvelfile = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_GVEL_FILE);
          message << "Writing group velocities into file " << gvelfile << ".";
          pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
          vector<vector<xvector<double> > > gvel = phcalc.calculateGroupVelocitiesOnMesh();
          phcalc.writeGroupVelocitiesToFile(gvelfile, gvel);
        }
        //QHA/SCQHA/QHA3P START //PN20180705
        //calculate Gruneisen
        //ME20190428 START
        //calculate group velocities
        if (!dosc.hasNegativeFrequencies()) {  //ME20200210
          // This is just here so that PN's code doesn't break. This should
          // become obsolete in the future.
          apl::QMesh& qmesh = phcalc.getQMesh();
          if (USER_DOS_PROJECTIONS.size() == 0) qmesh.makeIrreducible();  //ME20190625

          //ME20190428 END
          //QHA calculate Gruneisen
          std::vector< std::vector< double> > scqha_tv;
          if (CALCULATE_GRUNEISEN_OPTION.option   ||
              CALCULATE_GRUNEISEN_A_OPTION.option ||
              CALCULATE_GRUNEISEN_B_OPTION.option ||
              CALCULATE_GRUNEISEN_C_OPTION.option) {
            if(!is_negative_freq){
              apl::QHA qha(phcalc, *pheos, logger);
              qha.get_tmp_dir_name(_TMPDIR_);
              qha.set_cutoff_freq(CUTOFF_FREQ);
              if(qha.set_imported_variables())
              {
                //QHA Grunneisen parameter calculations     
                if(qha.calculation_gruneisen(&qmesh))  //ME20190428
                {
                  qha.write_gruneisen_parameter_mesh();
                  qha.Writeaverage_gp(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP);
                  is_negative_freq=qha.get_is_negative_freq();
                }
                //[OBSOLETE PN20180705]eos.clear();
              }
              if(CALCULATE_EOS_OPTION.option)
              {
                //QHA EOS calculations
                //[CO20181202 - NOT USED]apl::QH_ENERGIES eos_ens(*phcalc, *pheos, logger);
                apl::QH_ENERGIES eos_ens(*pheos, logger);
                eos_ens.get_tmp_dir_name(_TMPDIR_);
                eos_ens.get_xtracture(phcalc.getInputCellStructure());
                if(eos_ens.get_qha_energies())
                {     
                  apl::QHAEOS qheos(qha, eos_ens, logger);
                  qheos.set_fitting_type(FITTING_TYPE);
                  if(qheos.setvariables())
                  { 
                    qheos.set_include_ele(INCLUDE_ELE_OPTION.option);
                    qheos.cal_qheos(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP, tpc);
                  }
                  qheos.clear();
                  qha.clear();
                  //QHA3P and SCQHA calculations
                  if( (CALCULATE_SCQHA_OPTION.option || 
                        CALCULATE_SCQHA_A_OPTION.option || 
                        CALCULATE_SCQHA_B_OPTION.option || 
                        CALCULATE_SCQHA_C_OPTION.option ||
                        CALCULATE_QHA3P_OPTION.option || 
                        CALCULATE_QHA3P_A_OPTION.option || 
                        CALCULATE_QHA3P_B_OPTION.option || 
                        CALCULATE_QHA3P_C_OPTION.option) && (!scqha_is_vol_err) )
                  {         
                    if(!is_negative_freq){
                      apl::SCQHA_QHA3P scqha(phcalc, *pheos, logger);
                      scqha.get_tmp_dir_name(_TMPDIR_);
                      scqha.set_cutoff_freq(CUTOFF_FREQ);
                      if(scqha.set_imported_variables())
                      {    
                        //QHA3P Gruneisen parameter calculations 
                        //if(scqha.calculation_gruneisen(&umesh))  OBSOLETE ME20190428
                        if(scqha.calculation_gruneisen(&qmesh))  //ME20190428
                        {
                          if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                          { //PN20180719
                            scqha.write_gruneisen_parameter_mesh();
                            scqha.Writeaverage_gp(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP);
                            is_negative_freq=scqha.get_is_negative_freq();
                          }
                        }
                        //[OBSOLETE PN20180705]pheos->clear();
                      }
                      if(!is_negative_freq) //PN20180705
                      {   
                        //SCQHA EOS
                        if(kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A)
                        {
                          apl::SCQHAEOS scqhaeos(scqha, eos_ens, logger);
                          if(scqhaeos.import_variables())
                          { 
                            scqhaeos.set_input_temperature(scqha_pdis_T);
                            scqhaeos.sccycle(USER_TP_TSTART,USER_TP_TEND, 0.1);
                            scqha_tv=scqhaeos.get_TV_data();
                          } 
                          scqhaeos.clear();
                        }
                        //QHA3P EOS
                        if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                        {
                          apl::QHA3POINTS qha3points(scqha, eos_ens, logger);
                          if(qha3points.import_variables())
                          {
                            qha3points.set_include_ele(INCLUDE_ELE_OPTION.option);
                            qha3points.qha3pts_temperature_loop(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP, tpc);
                          }
                          qha3points.clear();
                        }
                      }
                      eos_ens.clear();
                      scqha.clear();
                    }
                  }
                }
              }
            } //QHA3P and SCQHA calculations    
          } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A ||
              kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
          {
            //[CO20181202 - NOT USED]apl::QH_ENERGIES eos_ens(*phcalc, *pheos, logger);
            apl::QH_ENERGIES eos_ens(*pheos, logger);
            eos_ens.get_xtracture(phcalc.getInputCellStructure());
            eos_ens.get_tmp_dir_name(_TMPDIR_);
            if(eos_ens.get_scqha_energies())
            {
              if(!is_negative_freq){
                apl::SCQHA_QHA3P scqha(phcalc, *pheos, logger);
                scqha.get_tmp_dir_name(_TMPDIR_);
                scqha.set_cutoff_freq(CUTOFF_FREQ);
                if(scqha.set_imported_variables())
                {
                  //QHA3P Gruneisen parameter calculation
                  if(scqha.calculation_gruneisen(&qmesh))  //ME20190428
                  {
                    if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                    { //PN20180719
                      scqha.write_gruneisen_parameter_mesh();
                      scqha.Writeaverage_gp(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP);
                      is_negative_freq=scqha.get_is_negative_freq();
                    }
                  }
                }
                if(!is_negative_freq)
                {
                  //SCQHA calculations
                  if(kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C)
                  {
                    apl::SCQHAEOS scqhaeos(scqha, eos_ens, logger);
                    if(scqhaeos.import_variables())
                    {
                      scqhaeos.sccycle(USER_TP_TSTART,USER_TP_TEND, 0.1);
                    }
                    scqhaeos.clear();
                  }
                  //QHA3P calculations
                  if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                  {
                    apl::QHA3POINTS qha3points(scqha, eos_ens, logger);
                    if(qha3points.import_variables())
                    {
                      qha3points.set_include_ele(INCLUDE_ELE_OPTION.option);
                      qha3points.qha3pts_temperature_loop(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP, tpc);
                    }
                    qha3points.clear();
                  }
                }
                scqha.clear();
              }
            }
            eos_ens.clear();
          }
          //compute SCQHA temperature dependent dispersion curve
          if((scqha_tv.size()!=0) && (SCQHA_PDIS_T_OPTION.option)){
            apl::T_spectra_SCQHA_QHA3P scqha_T(phcalc, *pheos, logger);
            scqha_T.get_tmp_dir_name(_TMPDIR_);
            scqha_T.set_cutoff_freq(CUTOFF_FREQ);
            scqha_T.get_input_data(scqha_tv);
            if(scqha_T.set_imported_variables())
            {
              if(scqha_T.calculation_freqs(ptr_hsq->get_qpoints()))
              {
                scqha_T.calculate_pdis_T(ptr_hsq->get_path(), ptr_hsq->get_path_segment());
              }
            }
            scqha_T.clear();
          }
          if(ptr_hsq.get()) ptr_hsq->clear();  //ME20190423
          //QHA/SCQHA/QHA3P END
        } else {
          //ME20200210 - changed warning
          const vector<double>& freqs = dosc.getBins();
          const vector<double>& idos = dosc.getIDOS();
          uint i = 0;
          for (i = 0; i < freqs.size(); i++) {
            if (freqs[i] > -_ZERO_TOL_LOOSE_) break;
          }
          if (i > 0) {
            double idos_percent = 100.0 * idos[i - 1]/idos.back();
            // Cannot use std::setprecision with apl:logger, so use this workaround.
            stringstream percent;
            percent << std::fixed << std::setprecision(1) << idos_percent;
            message << "There are imaginary frequencies in the phonon DOS, covering "
              << percent.str() << "\% of the integrated DOS. These frequencies were "
              << " omitted in the calculation of thermodynamic properties.";
            pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
          }
        }
      }
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                         THERMAL CONDUCTIVITY                            //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << function << " DEBUG [6]" << std::endl;

    if (USER_TCOND) {
      message << "Starting thermal conductivity calculations.";
      pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);

      apl::TCONDCalculator tcond(phcalc, aaplopts);
      tcond.calculateGrueneisenParameters();
      tcond.calculateThermalConductivity();
      tcond.writeOutputFiles(phcalc.getDirectory());
    }
  }
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                 VALIDATORS                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  void validateParametersAPL(aurostd::xoption& aplopts, const _aflags& aflags, ofstream& messageFile, ostream& oss) {
    string function = "apl::validateParametersAPL():";
    stringstream message;
    vector<string> tokens;

    if (XHOST.GENERATE_AFLOWIN_ONLY && aplopts.flag("RELAX")) {
      aplopts.flag("RELAX", false);
      message << "RELAX will be switched OFF for generate_aflowin_only.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss);
    }

    // Correct user engine
    string USER_ENGINE = aurostd::toupper(aplopts.getattachedscheme("ENGINE"));
    if (USER_ENGINE == "GSA") {
      message << "The Generalized Supercell Approach (GSA) is deprecated - replaced with the Direct Method (DM).";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss, _LOGGER_WARNING_);
      USER_ENGINE = "DM";
    }
    if ((USER_ENGINE != "DM") && (USER_ENGINE != "LR")) {
      message << "Wrong setting in [AFLOW_APL]ENGINE. Use either DM or LR. ";
      message << "See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
    }
    aplopts.push_attached("ENGINE", USER_ENGINE);  // To make sure it's all caps

    validateParametersSupercellAPL(aplopts);

    if (aplopts.flag("DC")) {
      validateParametersDispersionsAPL(aplopts);
    }
    if (aplopts.flag("DOS") || aplopts.flag("TP")) {
      validateParametersDosAPL(aplopts, aflags, messageFile, oss);
    }
  }

  void validateParametersSupercellAPL(aurostd::xoption& aplopts) {
    if (aplopts.flag("SUPERCELL")) {
      vector<int> tokens;
      string supercell_scheme = aplopts.getattachedscheme("SUPERCELL");
      aurostd::string2tokens(supercell_scheme, tokens, " xX");
      if (tokens.size() != 3) {
        string function = "apl::validateParametersSupercellAPL():";
        string message = "Wrong setting in [AFLOW_APL]SUPERCELL.";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }
      aplopts.push_attached("SUPERCELL::METHOD", "SUPERCELL");
      aplopts.push_attached("SUPERCELL::VALUE", supercell_scheme);
      aplopts.flag("MINATOMS", false);
      aplopts.flag("MINATOMS_RESTRICTED", false);
      aplopts.flag("MINSHELL", false);
    } else if (aplopts.flag("MINATOMS") || aplopts.flag("MINATOMS_RESTRICTED")) {
      if (aplopts.flag("MINATOMS_RESTRICTED")) {
        aplopts.push_attached("SUPERCELL::METHOD", "MINATOMS_RESTRICTED");
        aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINATOMS_RESTRICTED"));
        aplopts.flag("MINATOMS", false);
      } else {
        aplopts.push_attached("SUPERCELL::METHOD", "MINATOMS");
        aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINATOMS"));
      }
      aplopts.flag("SUPERCELL", false);
      aplopts.flag("MINSHELL", false);
    } else if (aplopts.flag("MINSHELL")) {
      aplopts.push_attached("SUPERCELL::METHOD", "SHELLS");
      aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINSHELL"));
      aplopts.flag("SUPERCELL", false);
      aplopts.flag("MINATOMS_RESTRICTED", false);
      aplopts.flag("MINATOMS", false);
    } else { // Default: MINATOMS
      aplopts.push_attached("SUPERCELL::METHOD", "MINATOMS");
      aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINATOMS"));
      aplopts.flag("SUPERCELL", false);
      aplopts.flag("MINATOMS_RESTRICTED", false);
      aplopts.flag("MINSHELL", false);
    }
  }

  void validateParametersDispersionsAPL(aurostd::xoption& aplopts) {
    string function = "apl::validateParametersDispersionsAPL():";
    string message = "";
    vector<string> tokens;
    string scheme = "";

    scheme = aurostd::toupper(aplopts.getattachedscheme("DCPATH"));
    if (scheme == "MANUAL") {
      string dc_initcoords_cart = aplopts.getattachedscheme("DCINITCOORDSCART");
      string dc_initcoords_frac = aplopts.getattachedscheme("DCINITCOORDSFRAC");
      if (dc_initcoords_cart.empty()) {
        aplopts.push_attached("DCINITCOORDS", dc_initcoords_frac);
        aurostd::string2tokens(dc_initcoords_frac, tokens, "  ;");
        aplopts.flag("DCCOORDS_FRAC", true);
        aplopts.flag("DCCOORDS_CART", false);
      } else {
        aplopts.push_attached("DCINITCOORDS", dc_initcoords_cart);
        aurostd::string2tokens(dc_initcoords_cart, tokens, "  ;");
        aplopts.flag("DCCOORDS_FRAC", false);
        aplopts.flag("DCCOORDS_CART", true);
      }
      uint ncoords = tokens.size();
      aurostd::string2tokens(aplopts.getattachedscheme("DCINITCOORDSLABELS"), tokens, " ,;");
      if (ncoords != tokens.size()) {
        message = "Mismatch between the number of points and the number of labels for the phonon dispersions. ";
        message += "Check the parameters DCINITCOORDS" + string(dc_initcoords_frac.empty()?"CART":"FRAC") + " and DCINITCOORDSLABELS.";
        message += "See README_AFLOW_APL.TXT for more information.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }
    } else if (scheme != "LATTICE") {
      message = "Wrong setting in [AFLOW_APL]DCPATH. Use either LATTICE or MANUAL. ";
      message += "See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
    }
    aplopts.push_attached("DCPATH", scheme);  // to make sure it's all caps
  }

  void validateParametersDosAPL(aurostd::xoption& aplopts, const _aflags& aflags, ofstream& messageFile, ostream& oss) {
    string function = "apl::validateParametersDosAPL():";
    string message = "";
    vector<string> tokens;

    // DOS Method
    string dos_method = aurostd::toupper(aplopts.getattachedscheme("DOSMETHOD"));
    if ((dos_method != "LT") && (dos_method != "RS")) {
      message = "Wrong setting in DOSMETHOD. Use either LT or RS.";
      message += " See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
    }
    aplopts.push_attached("DOSMETHOD", dos_method);  // To make sure the option is all caps
    double dos_smear = aurostd::string2utype<double>(aplopts.getattachedscheme("DOSSMEAR"));
    if ((dos_method == "RS") && (dos_smear < _ZERO_TOL_)) {
      message = "Smearing value for DOS not set or set to zero.";
      message += " APL will overwrite the smearing value to 0.05 eV.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss, _LOGGER_WARNING_);
      aplopts.push_attached("DOSSMEAR", "0.05");
    }

    // q-point mesh
    aurostd::string2tokens(aplopts.getattachedscheme("DOSMESH"), tokens, " xX");
    if (tokens.size() != 3) {
      message = "Wrong setting in DOSMESH.";
      message += " See README_AFLOW_APL.TXT for the correct format.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
    }

    // DOS projections
    if (aplopts.flag("DOS_PROJECT")) {
      string dos_proj_cart = aplopts.getattachedscheme("DOSPROJECTIONS_CART");
      string dos_proj_frac = aplopts.getattachedscheme("DOSPROJECTIONS_FRAC");
      if (!dos_proj_frac.empty() || !dos_proj_cart.empty()) {
        if (!dos_proj_cart.empty() && !dos_proj_frac.empty()) {
          message = "Ambiguous input in APL DOS projections.";
          message += " Choose between DOSPROJECTIONS_CART and DOSPROJECTIONS_FRAC.";
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_AMBIGUOUS_);
        } else {
          string projscheme;
          if (!dos_proj_cart.empty()) {
            aplopts.flag("DOS_CART", true);
            aplopts.flag("DOS_FRAC", false);
            projscheme = dos_proj_cart;
          } else {
            aplopts.flag("DOS_CART", false);
            aplopts.flag("DOS_FRAC", true);
            projscheme = dos_proj_frac;
          }
          tokens.clear();
          aurostd::string2tokens(projscheme, tokens, "; ");
          for (uint i = 0; i < tokens.size(); i++) {
            vector<string> proj;
            aurostd::string2tokens(tokens[i], proj, ", ");
            if (proj.size() != 3) {
              message = "Wrong setting in DOSPROJECTIONS_";
              message += string(dos_proj_cart.empty()?"FRAC":"CART") + ".";
              message += " See README_AFLOW_APL.TXT for the correct format.";
              throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
            }
          }
        }
      }
    }

    // Thermal properties temperature
    if (aplopts.flag("TP")) {
      aurostd::string2tokens(aplopts.getattachedscheme("TPT"), tokens, " :");
      if (tokens.size() != 3) {
        message = "Wrong setting in [AFLOW_APL]TPT. ";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }
      double tstart = aurostd::string2utype<double>(tokens[0]);
      double tend = aurostd::string2utype<double>(tokens[1]);
      double tstep = aurostd::string2utype<double>(tokens[2]);
      if (tstart > tend) {
        message = "Start temperature is larger than end temperature.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _VALUE_ILLEGAL_);
      }
      if (tstep < _ZERO_TOL_) {
        message = "Temperature step cannot be zero or negative.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _VALUE_ILLEGAL_);
      }
      aplopts.push_attached("TSTART", tokens[0]);
      aplopts.push_attached("TEND", tokens[1]);
      aplopts.push_attached("TSTEP", tokens[2]);
    }
  }

  // Checks that the AAPL parameters are valid and recasts them to be usable
  // by all AAPL classes.
  void validateParametersAAPL(xoption& aaplopts, const _aflags& aflags, ofstream& messageFile, ostream& oss) {
    string function = "apl::validateParametersAAPL()";
    string _ASTROPT_ = "[AFLOW_AAPL]";
    string module = "AAPL";
    string scheme = "", message = "";
    vector<string> tokens;

    // BTE
    scheme = aaplopts.getattachedscheme("BTE");
    if ((scheme != "RTA") && (scheme != "FULL")) {
      message = "Wrong setting in " + _ASTROPT_ + "BTE. Use either RTA or FULL.";
      message += " See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
    }

    // CUT_SHELL and CUT_RAD
    bool defaults = (!aaplopts.flag("CUT_SHELL") && !aaplopts.flag("CUT_RAD"));  // flag is false when isentry was false
    bool fourth_order = aaplopts.flag("FOURTH_ORDER");
    if (defaults || aaplopts.flag("CUT_RAD")) {
      aurostd::string2tokens(aaplopts.getattachedscheme("CUT_RAD"), tokens, " ,");
      if (tokens.size() < 1) {
        message = "Not enough entries in " + _ASTROPT_ + "CUT_RAD. ";
        message += "See README_AFLOW_APL.TXT for more information.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      } else if (tokens.size() > 2) {
        message = "Too many entries for " + _ASTROPT_ + "CUT_RAD. Excess entries will be ignored.";
        pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, messageFile, oss, _LOGGER_WARNING_);
      } 
      if (aaplopts.flag("FOURTH_ORDER")) {
        if (tokens.size() == 1) {
          message = "Only one entry found for the cutoff radius. 3rd and 4th order anharmonic IFCs will use the same value.";
          pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, messageFile, oss, _LOGGER_WARNING_);
          aaplopts.push_attached("CUT_RAD", tokens[0] + "," + tokens[0]);
        } else {
          aaplopts.push_attached("CUT_RAD", tokens[0] + "," + tokens[1]);
        }
      } else {
        aaplopts.push_attached("CUT_RAD", tokens[0]);
      }
    }
    if (defaults || aaplopts.flag("CUT_SHELL")) {
      aurostd::string2tokens(aaplopts.getattachedscheme("CUT_SHELL"), tokens, " ,");
      if (tokens.size() < 1) {
        message = "Not enough entries in " + _ASTROPT_ + "CUT_SHELL. ";
        message += "See README_AFLOW_APL.TXT for more information.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      } else if (tokens.size() > 2) {
        message = "Too many entries for " + _ASTROPT_ + "CUT_SHELL. Excess entries will be ignored.";
        pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, messageFile, oss, _LOGGER_WARNING_);
      } 
      if (aaplopts.flag("FOURTH_ORDER")) {
        if (tokens.size() == 1) {
          message = "Only one entry found for the cutoff shells. 3rd and 4th order anharmonic IFCs will use the same value.";
          pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, messageFile, oss, _LOGGER_WARNING_);
          aaplopts.push_attached("CUT_SHELL", tokens[0] + "," + tokens[0]);
        } else {
          aaplopts.push_attached("CUT_SHELL", tokens[0] + "," + tokens[1]);
        }
      } else {
        aaplopts.push_attached("CUT_SHELL", tokens[0]);
      }
    }
    // if only one parameter is set in the aflow.in file, unset the other
    if (aaplopts.flag("CUT_RAD") != aaplopts.flag("CUT_SHELL")) {
      if (!aaplopts.flag("CUT_RAD")) aaplopts.push_attached("CUT_RAD", (fourth_order?"0.0,0.0":"0.0"));
      if (!aaplopts.flag("CUT_SHELL")) aaplopts.push_attached("CUT_RAD", (fourth_order?"0,0":"0"));
    }

    // THERMALGRID
    scheme = aaplopts.getattachedscheme("THERMALGRID");
    aurostd::string2tokens(scheme, tokens, string(" xX"));
    if (tokens.size() != 3) {
      message = "Wrong setting in " + _ASTROPT_ + "THERMALGRID. ";
      message += "See README_AFLOW_APL.TXT for the correct format.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
    }

    // TCT
    scheme = aaplopts.getattachedscheme("TCT");
    aurostd::string2tokens(scheme, tokens, string(" :"));
    if (tokens.size() == 3) {
      double USER_TCT_TSTART = aurostd::string2utype<double>(tokens[0]);
      double USER_TCT_TEND = aurostd::string2utype<double>(tokens[1]);
      double USER_TCT_TSTEP = aurostd::string2utype<double>(tokens[2]);
      if (USER_TCT_TSTEP < _ZERO_TOL_) {
        message = "Temperature step cannot be zero.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
      if (USER_TCT_TSTART == 0) {
        message = "Thermal conductivity is infinite at 0 K and will be skipped.";
        pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, messageFile, oss);
        USER_TCT_TSTART += USER_TCT_TSTEP;
      }
      if (USER_TCT_TSTART > USER_TCT_TEND) {
        message = "Start temperature cannot be larger than final temperature.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
      aaplopts.push_attached("TSTART", aurostd::utype2string<double>(USER_TCT_TSTART));
      aaplopts.push_attached("TEND", aurostd::utype2string<double>(USER_TCT_TEND));
      aaplopts.push_attached("TSTEP", aurostd::utype2string<double>(USER_TCT_TSTEP));
    } else {
      message = "Wrong setting in " + _ASTROPT_ + "TCT. ";
      message += "See README_AFLOW_APL.TXT for the correct format.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
    }

    // BOUNDARY and CUMULATIVEK
    if (aaplopts.flag("BOUNDARY") && aaplopts.flag("CUMULATIVEK")) {
      aaplopts.flag("CUMULATIVEK", false);
      message = "Both boundary effects and cumulative thermal conductivity cannot be set at the same time.";
      message += " Cumulative thermal conductivity has been switched off.";
      pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, messageFile, oss, _LOGGER_WARNING_);
    }
  }
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                            INPUT FILE CREATORS                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  //createAflowInPhonons////////////////////////////////////////////////////////
  //ME20181022 - New method to create the aflow.in files. Uses the aflow.in
  // creator in aflow_avasp.cpp
  bool createAflowInPhonons(const _aflags& _aflowFlags, const _kflags& _kbinFlags, const _xflags& _xFlags, _xinput& xinp) {
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string soliloquy="apl::createAflowInPhonons():";
    bool write = false;
    if (xinp.AFLOW_MODE_VASP) {
      if(LDEBUG){
        std::cerr << soliloquy << " BEFORE xinp.xvasp.Directory=" << xinp.xvasp.Directory << std::endl;
        std::cerr << soliloquy << " BEFORE xinp.getDirectory()=" << xinp.getDirectory() << std::endl;
      }
      AVASP_populateXVASP(_aflowFlags, _kbinFlags, _xFlags.vflags, xinp.xvasp);
      if(LDEBUG){
        std::cerr << soliloquy << " AFTER xinp.xvasp.Directory=" << xinp.xvasp.Directory << std::endl;
        std::cerr << soliloquy << " AFTER xinp.getDirectory()=" << xinp.getDirectory() << std::endl;
      }
      xinp.setDirectory(xinp.xvasp.Directory);
      if (!filesExistPhonons(xinp)) {
        stringstream aflowin;
        write = true;
        AVASP_MakeSingleAFLOWIN(xinp.xvasp, aflowin, write);
      } else {
        write = false;
      }
    }
    return write;
  }

  //ME20181022 - Old method to create aflow.in files for AIMS
  void createAflowInPhononsAIMS(_aflags& _aflowFlags, _kflags& _kbinFlags, _xflags& _xFlags, string& _AflowIn, _xinput& xinp, ofstream& messageFile) {
    string function = "apl::createAflowInPhononsAIMS():";
    string message = "";
    if (!xinp.AFLOW_MODE_AIMS) {
      message = "This function only works with AIMS.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _RUNTIME_ERROR_);
    }
    xinp.xaims.CONTROL.str(std::string());
    KBIN::AIMS_Produce_CONTROL(xinp.xaims,_AflowIn,messageFile,_aflowFlags,_kbinFlags,_xFlags.aimsflags);  //DEFAULT
    KBIN::AIMS_Modify_CONTROL(xinp.xaims,messageFile,_aflowFlags,_kbinFlags,_xFlags.aimsflags);            //DEFAULT

    // Write aflow.in

    //copying from createAFLOWIN
    _vflags vflags(_xFlags.vflags);
    _xaims xaims(xinp.xaims);
    _aimsflags aimsflags(_xFlags.aimsflags);

    string directory=xinp.getDirectory();
    if(directory.empty()){
      message = "No output directory found";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _RUNTIME_ERROR_);
    }

    if(!aurostd::FileExist(directory)){aurostd::DirectoryMake(directory);}  // Create directory if it is not created
    aurostd::DirectoryChmod("777", directory);                              // CHMOD Directory 777

    stringstream outfile;

    // OK, fill it...
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AFLOW] _ ___ _" << std::endl;
    outfile << "[AFLOW] / \\| o \\ |" << std::endl;
    outfile << "[AFLOW] | o | _/ |_" << std::endl;
    outfile << "[AFLOW] |_n_|_| |___| automatic generated file" << std::endl;
    outfile << "[AFLOW]" << std::endl;
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AFLOW_MODE=AIMS]" << std::endl;
    if(!_kbinFlags.KZIP_BIN.empty()){outfile << "[AFLOW_MODE_ZIP=" << _kbinFlags.KZIP_BIN << "]" << std::endl;}  //CO

    //CO20180130 START
    //CO - at some point, fix alien mode for aims, for now omit!
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AIMS_CONTROL_MODE_EXPLICIT]START " << std::endl;
    outfile << xaims.CONTROL.str();
    outfile << "[AIMS_CONTROL_MODE_EXPLICIT]STOP " << std::endl;
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AIMS_GEOM_MODE_EXPLICIT]START " << std::endl;
    outfile << xaims.str;
    outfile << "[AIMS_GEOM_MODE_EXPLICIT]STOP " << std::endl;
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;

    //also write out
    if(1){
      KBIN::AIMS_Write_CONTROL(xaims,aimsflags);
      xaims.GEOM.clear(); xaims.GEOM.str("");
      xaims.GEOM << xaims.str;

      string geom_filename = xaims.Directory + "/" + AFLOWRC_DEFAULT_AIMS_EXTERNAL_GEOM;
      aurostd::stringstream2file(xaims.GEOM, geom_filename);
      if(!aurostd::FileExist(geom_filename)){
        message = "Cannot create [" + AFLOWRC_DEFAULT_AIMS_EXTERNAL_GEOM + "] file.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _FILE_ERROR_);
      }
      aurostd::ChmodFile("a+rw", geom_filename);
    }

    //CO START
    string filename = directory + string("/") + _AFLOWIN_;
    aurostd::stringstream2file(outfile, filename);
    if (!aurostd::FileExist(filename)){
      message = "Cannot create [" + _AFLOWIN_ + "] file.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _FILE_ERROR_);
    }
    aurostd::ChmodFile("a+rw", filename); // CHMOD a+rw _AFLOWIN_
    //CO END
  }

}  // namespace apl

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                           OUTPUT FILE READERS                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  //outfileFoundAnywherePhonons/////////////////////////////////////////////////
  // Checks if output files can be found anywhere. If true, APL will assume that
  // no DFT calculations have run yet --> stagebreak
  bool outfileFoundAnywherePhonons(vector<_xinput>& xinps) {
    for (uint idxRun = 0; idxRun < xinps.size(); idxRun++) {
      string dir = xinps[idxRun].getDirectory();

      if(xinps[idxRun].AFLOW_MODE_VASP) {
        if(aurostd::EFileExist(dir + string("/vasprun.xml.static")) ||
            aurostd::EFileExist(dir + string("/vasprun.xml")) ||
            aurostd::EFileExist(dir + "/" + DEFAULT_AFLOW_QMVASP_OUT)) {  //ME20190607
          return true;
        }
      }
      if(xinps[idxRun].AFLOW_MODE_AIMS) {
        if(aurostd::EFileExist(xinps[idxRun].getDirectory() + string("/aims.out"))) {
          return true;
        }
      }
    }
    return false;
  }

  //filesExistPhonons/////////////////////////////////////////////////////////
  bool filesExistPhonons(_xinput& xinp) {
    string dir = xinp.getDirectory() + string("/");
    if (aurostd::FileExist(dir + _AFLOWIN_)) {
      return true;  //do not OVERWRITE an aflow.in
    }
    if (xinp.AFLOW_MODE_VASP){
      if(aurostd::EFileExist(dir + string("vasprun.xml.static")) ||
          aurostd::EFileExist(dir + string("vasprun.xml")) ||
          aurostd::EFileExist(dir + DEFAULT_AFLOW_QMVASP_OUT)) {  //ME20200203 - Added qmvasp file
        return true;
      }
    }
    if(xinp.AFLOW_MODE_AIMS){
      if(aurostd::EFileExist(dir + string("aims.out"))) {
        return true;
      }
    }
    return false;
  }

  //outfileFoundEverywherePhonons/////////////////////////////////////////////
  // Tests whether the necessary force files are present and complete in all
  // directories for the phonon calculatios. Also reads all forces. If false,
  // APL will assume that at least one DFT broke --> error
  bool outfileFoundEverywherePhonons(vector<_xinput>& xinps, const string& directory, ofstream& messageFile, ostream& oss, bool contains_born) {
    string mode = xinps[0].xvasp.AVASP_arun_mode;
    stringstream _logger;
    _logger << "Reading force files.";
    pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, directory, messageFile, oss);
    uint ninps = xinps.size();
    if (contains_born) ninps--;
    for (uint idxRun = 0; idxRun < ninps; idxRun++) {
      _logger << "Reading force file " << (idxRun + 1) << "/" << ninps << "."; //CO20190116  //ME20190607
      pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, xinps[idxRun].getDirectory(), messageFile, oss);
      string directory = xinps[idxRun].getDirectory();
      if (!readForcesFromDirectory(xinps[idxRun])) {
        _logger << "The force file in " << xinps[idxRun].getDirectory() << " directory is missing.";
        pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, xinps[idxRun].getDirectory(), messageFile, oss);
        return false;
      }

      // Was it all right?
      if (!xinps[idxRun].getXStr().qm_calculated) {
        string function = "apl::outfileFoundEverywherePhonons():";
        string message = "The force file in " + directory + " is wrong.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _FILE_CORRUPT_);
      }
    }
    _logger << "No errors caught, all force files read successfully."; //CO20190116  //ME20190607
    pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, directory, messageFile, oss, _LOGGER_COMPLETE_);
    return true;
  }

  bool readForcesFromDirectory(_xinput& xinp) {
    string function = "apl::readForcesFromDirectory():";
    uint natoms = xinp.getXStr().atoms.size();
    xinp.getXStr().qm_forces.clear();
    // Load data....
    if(xinp.AFLOW_MODE_VASP) {
      if (!aurostd::EFileExist(xinp.getDirectory() + "/" + DEFAULT_AFLOW_QMVASP_OUT)
          && !aurostd::EFileExist(xinp.getDirectory() + "/vasprun.xml.static")
          && !aurostd::EFileExist(xinp.getDirectory() + "/vasprun.xml")) {
        return false;
      }
      //ME20190607 BEGIN
      // Read forces from aflow qmvasp file - much faster
      string file = xinp.getDirectory() + "/" + DEFAULT_AFLOW_QMVASP_OUT;
      if (aurostd::EFileExist(file)) {
        xQMVASP qmvasp(file);
        xinp.getXStr().qm_forces = qmvasp.vforces;
      } else {
        file = xinp.getDirectory() + string("/vasprun.xml.static");
        if(!aurostd::EFileExist(file)) file = xinp.getDirectory() + string("/vasprun.xml");
        //xVASPRUNXML vasprunxml(file); OBSOLETE ME20190204 - far too slow
        xVASPRUNXML vasprunxml;
        vasprunxml.GetForcesFile(file);
        for (uint i = 0; i < vasprunxml.vforces.size(); i++) xinp.getXStr().qm_forces.push_back(vasprunxml.vforces[i]);
      }
      if (xinp.getXStr().qm_forces.size() == natoms) xinp.getXStr().qm_calculated = true;
      return true;
    } else if (xinp.AFLOW_MODE_AIMS){
      if(!aurostd::EFileExist(xinp.getDirectory() + string("/aims.out"))) {
        return false;
      }
      xAIMSOUT xaimsout(xinp.getDirectory() + "/aims.out");
      for (uint i = 0; i < xaimsout.vforces.size(); i++) xinp.getXStr().qm_forces.push_back(xaimsout.vforces[i]);
      if (xinp.getXStr().qm_forces.size() == natoms) xinp.getXStr().qm_calculated = true;
      return true;
    } else {
      return false;
    }
  }

  //subtractZeroStateForces///////////////////////////////////////////////////
  void subtractZeroStateForces(vector<_xinput>& xinps, bool contains_born) {
    uint ninps = xinps.size() - 1;
    if (contains_born) ninps--;
    uint natoms = xinps[ninps].getXStr().atoms.size();
    for (uint idxRun = 0; idxRun < ninps; idxRun++) {
      if (xinps[idxRun].getXStr().atoms.size() != natoms) {
        string function = "apl::subtractZeroStateForces():";
        string message = "Structure and ZEROSTATE structure do not have the same number of atoms.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INDEX_MISMATCH_);
      }
      for (uint k = 0; k < natoms; k++) {
        xinps[idxRun].getXStr().qm_forces[k](1) = xinps[idxRun].getXStr().qm_forces[k](1) - xinps[ninps].getXStr().qm_forces[k](1);
        xinps[idxRun].getXStr().qm_forces[k](2) = xinps[idxRun].getXStr().qm_forces[k](2) - xinps[ninps].getXStr().qm_forces[k](2);
        xinps[idxRun].getXStr().qm_forces[k](3) = xinps[idxRun].getXStr().qm_forces[k](3) - xinps[ninps].getXStr().qm_forces[k](3);
      }
    }
  }

  //ME20190114
  // Cannot use const reference for zerostate because of getXStr()
  // This is used for AAPL and needs an extra input because the ZEROSTATE
  // calculation is not part of the xInputs vector
  void subtractZeroStateForces(vector<_xinput>& xinps, _xinput& zerostate) {
    string function = "apl::subtractZeroStateForces():";
    string message = "";
    stringstream _logger;
    uint natoms = zerostate.getXStr().atoms.size();
    if (!zerostate.getXStr().qm_calculated) {
      readForcesFromDirectory(zerostate);
      if (!zerostate.getXStr().qm_calculated) {
        message = "The force file in " + zerostate.getDirectory() + " is wrong.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _FILE_CORRUPT_);
      }
    }
    for (uint idxRun = 0; idxRun < xinps.size(); idxRun++) {
      if (xinps[idxRun].getXStr().atoms.size() != natoms) {
        message = "Structure and ZEROSTATE structure do not have the same number of atoms.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INDEX_MISMATCH_);
      }
      for (uint at = 0; at < natoms; at++) {
        xinps[idxRun].getXStr().qm_forces[at](1) = xinps[idxRun].getXStr().qm_forces[at](1) - zerostate.getXStr().qm_forces[at](1);
        xinps[idxRun].getXStr().qm_forces[at](2) = xinps[idxRun].getXStr().qm_forces[at](2) - zerostate.getXStr().qm_forces[at](2);
        xinps[idxRun].getXStr().qm_forces[at](3) = xinps[idxRun].getXStr().qm_forces[at](3) - zerostate.getXStr().qm_forces[at](3);
      }
    }
  }

}  // namespace apl

// ***************************************************************************
// *                                                                         *
// *             STEFANO CURTAROLO - Duke University 2003-2020               *
// *                                                                         *
// ***************************************************************************
