// ***************************************************************************
// *                                                                         *
// *             STEFANO CURTAROLO - Duke University 2003-2020               *
// *                                                                         *
// ***************************************************************************

#include "../aflow.h"
#include "aflow_apl.h"

#define _ASTROPT_APL_OLD_ string("[AFLOW_PHONONS]") //CO20170601, ensure backwards compatibility (we ALWAYS support LEGACY)
#define _ASTROPT_APL_ string("[AFLOW_APL]") //CO20170601
#define _ASTROPT_QHA_ string("[AFLOW_QHA]") //CO20170601
#define _ASTROPT_AAPL_ string("[AFLOW_AAPL]") //CO20170601
//temporary directory for storing QHA files
#define _TMPDIR_ string("ARUN.APL.QH.TMP")  //[PN]
#define _STROPT_ string("[VASP_FORCE_OPTION]") //ME20181226

bool _WITHIN_DUKE_ = false;

//CO fixing cpp version issues with auto_ptr (depreciated)
#if __cplusplus >= 201103L
template <typename T>
using auto_ptr = std::unique_ptr<T>;
#else
using std::auto_ptr;
#endif

static const string _ANHARMONIC_IFCS_FILE_[2] = {"anharmonicIFCs_3rd.xml", "anharmonicIFCs_4th.xml"};
static const string _CLUSTER_SET_FILE_[2] = {"clusterSet_3rd.xml", "clusterSet_4th.xml"};
static const int _NUM_RELAX_ = 2; //ME20181226
static const string _APL_RELAX_PREFIX_ = "relax_apl"; //ME20181226  //ME20190125

namespace apl {
  //ME20190119
  // Old apl::tokenize is essentially just aurostd::string2tokens
  void tokenize(const string& strin, vector<string>& tokens, const string& del) {
    aurostd::string2tokens(strin, tokens, del);
  }
}

namespace KBIN {
  // ME20181107 - Relax structure with PREC=PHONONS before running APL
  // ME20200102 - Make k-point grid commensurate with supercell size
  bool relaxStructureAPL_VASP(int start_relax,
      const string& AflowIn,
      aurostd::xoption supercell_opts,  // ME20200102
      const xvector<int>& scell_dims,  // ME20200102
      bool relax_commensurate,
      _xvasp& xvasp,
      _aflags& aflags,
      _kflags& kflags,
      _vflags& vflags,
      ofstream& fileMessage,
      ostream& oss) {
    stringstream message;

    if (start_relax == _NUM_RELAX_) return true;  // Nothing to do here

    // Store original settings
    string prec = vflags.KBIN_VASP_FORCE_OPTION_PREC.xscheme;
    bool prec_entry = vflags.KBIN_VASP_FORCE_OPTION_PREC.isentry;
    aurostd::xoption kbin_vasp_run = vflags.KBIN_VASP_RUN;
    int nrelax = xvasp.NRELAX;

    // Change to RELAX
    vflags.KBIN_VASP_RUN.flag("RELAX", true);
    vflags.KBIN_VASP_RUN.flag("STATIC", false);
    vflags.KBIN_VASP_RUN.flag("RELAX_STATIC", false);
    vflags.KBIN_VASP_RUN.flag("RELAX_STATIC_BANDS", false);
    vflags.KBIN_VASP_RUN.flag("STATIC_BANDS", false);

    // Change to phonon settings
    string prec_phonons = xvasp.aplopts.getattachedscheme("AFLOWIN_FLAG::APL_PREC");
    vflags.KBIN_VASP_FORCE_OPTION_PREC.pop(prec);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.push(prec_phonons);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.isentry = true;

    // ME20200427
    bool Krun = true;
    if (relax_commensurate) {
      // Determine k-point grid that is commensurate with the grid of the supercell
      // ME20200102
      // Determine k-point grid that is commensurate with the k-point grid of
      // the supercell. APL automatically chooses the k-point grid for the
      // relaxation to be commensurate with the k-point grid for the supercell.
      // For example, if a 3x2x1 supercell uses a 2x2x3 k-point grid, the unit
      // cell will be relaxed using a 6x4x3 k-point grid. This minimizes the
      // risk of ghost forces in the supercell calculations.
      apl::Supercell scell(xvasp.str, fileMessage, oss, aflags.Directory);
      scell.build(scell_dims, false);
      string scheme_phonons = vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.content_string;
      int kppra_phonons = vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.content_int;
      xvector<int> kpts_sc(3), kpts_pc(3);
      if (vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) {
        int NK = (int) ((double) kppra_phonons/scell.getSupercellStructure().atoms.size() + 0.5);
        if (NK < 1) NK = 1;
        KPPRA(kpts_sc[1], kpts_sc[2], kpts_sc[3], scell.getSupercellStructure().lattice, NK);
      } else {
        vector<int> kpts;
        aurostd::string2tokens(vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string, kpts, " xX");
        kpts_sc = aurostd::vector2xvector(kpts);
      }
      for (int i = 1; i < 4; i++) kpts_pc[i] = scell_dims[i] * kpts_sc[i];
      message << "Relaxations will be performed on a " << aurostd::joinWDelimiter(kpts_pc, "x") << " k-point grid.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags.Directory, fileMessage, oss);

      // Create k-points file
      stringstream kpts_file;
      kpts_file << "k-points automaticalliy generated by APL," << " supercell = " << aurostd::joinWDelimiter(scell_dims, "x") << ",";
      if (vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) kpts_file << " kppra = " << kppra_phonons;
      kpts_file << " (k = " << aurostd::joinWDelimiter(kpts_sc, "x")  << ")" << std::endl;
      kpts_file << "0" << std::endl;
      kpts_file << scheme_phonons << std::endl;
      kpts_file << aurostd::joinWDelimiter(kpts_pc, " ") << std::endl;
      kpts_file << "0 0 0" << std::endl;

      // Store old settings and switch to k-points mode to explicit with new file
      aurostd::xoption kbin_vasp_kpoints_mode_back = vflags.KBIN_VASP_KPOINTS_MODE;
      aurostd::xoption kbin_vasp_kpoints_file_back = vflags.KBIN_VASP_KPOINTS_FILE;
      string kbin_vasp_kpoints_explicit_start_stop_back = vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str();
      vflags.KBIN_VASP_KPOINTS_MODE.clear();
      vflags.KBIN_VASP_KPOINTS_FILE.clear();
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str("");
      vflags.KBIN_VASP_KPOINTS_MODE.flag("EXPLICIT", true);
      vflags.KBIN_VASP_KPOINTS_MODE.flag("EXPLICIT_START_STOP", true);
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP << kpts_file.str();

      Krun = runRelaxationsAPL_VASP(start_relax, AflowIn, xvasp, aflags, kflags, vflags, fileMessage);

      // Consistency check: Redetermine the supercell dimensions and the k-point
      // grid for the supercell calculations with the relaxed structure. If they
      // do not agree, then the structure has changed too much and the relaxation
      // did not use an appropriate k-point grid.
      // The k-points scheme MUST be resolved pre-phonon-relaxation and made consistent
      // with the desired supercell dimensions, otherwise ghost-forces may appear.
      scell.clearSupercell();
      scell.initialize(xvasp.str);
      supercell_opts.flag("SCELL::VERBOSE", false);
      xvector<int> scell_dims_new = scell.determineSupercellDimensions(supercell_opts);
      if (scell_dims != scell_dims_new) {
        string function = "KBIN::relaxStructureAPL_VASP()";
        message << "Supercell dimensions of input structure (" << aurostd::joinWDelimiter(scell_dims, "x") << ")"
          << " and relaxed structure (" << aurostd::joinWDelimiter(scell_dims_new, "x") << ")"
          << " do not agree. This is likely due to different symmetries in these structures. Use"
          << " an input structure that is closer to the fully relaxed one, remove all"
          << " CONTCAR." << _APL_RELAX_PREFIX_ << "* files, and run APL again.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _RUNTIME_ERROR_);
      }
      // k-point grid comparison only relevant when KPPRA is used
      if (!vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) {
        xvector<int> kpts_sc_new(3);
        scell.build(scell_dims_new, false);
        int NK = (int) ((double) kppra_phonons/scell.getSupercellStructure().atoms.size() + 0.5);
        if (NK < 1) NK = 1;
        KPPRA(kpts_sc_new[1], kpts_sc_new[2], kpts_sc_new[3], scell.getSupercellStructure().lattice, NK);
        if (kpts_sc != kpts_sc_new) {
          string function = "KBIN::relaxStructureAPL_VASP()";
          message << "k-point grids  of the supercells of the input structure (" << aurostd::joinWDelimiter(kpts_sc, "x") << ")"
            << " and the relaxed structure (" << aurostd::joinWDelimiter(kpts_sc_new, "x") <<  ")"
            << " do not agree. This is likely due to different symmetries in these structures. Use"
            << " an input structure that is closer to the fully relaxed one, remove all"
            << " CONTCAR." << _APL_RELAX_PREFIX_ << "* files, and run APL again.";
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _RUNTIME_ERROR_);
        }
      }

      // Restore original settings
      vflags.KBIN_VASP_KPOINTS_MODE = kbin_vasp_kpoints_mode_back;
      vflags.KBIN_VASP_KPOINTS_FILE = kbin_vasp_kpoints_file_back;
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str("");
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP << kbin_vasp_kpoints_explicit_start_stop_back;
    } else {
      Krun = runRelaxationsAPL_VASP(start_relax, AflowIn, xvasp, aflags, kflags, vflags, fileMessage);
    }

    vflags.KBIN_VASP_FORCE_OPTION_PREC.pop(prec_phonons);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.push(prec);
    vflags.KBIN_VASP_FORCE_OPTION_KPOINTS.isentry = prec_entry;
    xvasp.NRELAX = nrelax;
    vflags.KBIN_VASP_RUN = kbin_vasp_run;

    return Krun;
  }

  bool runRelaxationsAPL_VASP(int start_relax, const string& AflowIn, _xvasp& xvasp,
    _aflags& aflags, _kflags& kflags, _vflags& vflags, ofstream& fileMessage) {
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    ostringstream aus;

    bool Krun = VASP_Produce_and_Modify_INPUT(xvasp, AflowIn, fileMessage, aflags, kflags, vflags);
    Krun = (Krun && VASP_Write_INPUT(xvasp, vflags));

    // ME20200115 - set for SPIN_REMOVE_RELAX
    xvasp.NRELAX = _NUM_RELAX_;

    if (Krun) {
      int i;
      for (i = start_relax; Krun && i <= _NUM_RELAX_; i++) {
        aus << 11111*i << " RELAXATION APL - " << xvasp.Directory << " - K=[" << xvasp.str.kpoints_k1 << " " << xvasp.str.kpoints_k2 << " " << xvasp.str.kpoints_k3 << "]" << " - " << kflags.KBIN_BIN << " - " << Message("user,host,time") << endl;
        aurostd::PrintMessageStream(fileMessage, aus, XHOST.QUIET);
        if (i < _NUM_RELAX_) {
          Krun = VASP_Run(xvasp, aflags, kflags, vflags, _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), true, fileMessage);
          XVASP_INCAR_SPIN_REMOVE_RELAX(xvasp, aflags, vflags, i, fileMessage);
          XVASP_KPOINTS_IBZKPT_UPDATE(xvasp, aflags, vflags, i, fileMessage);
        } else { 
          Krun = VASP_Run(xvasp, aflags, kflags, vflags, _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), true, fileMessage);
          XVASP_INCAR_SPIN_REMOVE_RELAX(xvasp, aflags, vflags, i, fileMessage);  // ME20200115 - or else SPIN_REMOVE_RELAX_2 does not work
        }
      }
      if (Krun && (i == _NUM_RELAX_)) {
        aus << 11111*i << " RELAXATION APL END - " << xvasp.Directory << " - K=[" << xvasp.str.kpoints_k1 << " " << xvasp.str.kpoints_k2 << " " << xvasp.str.kpoints_k3 << "]" << " - " << kflags.KBIN_BIN << " - " << Message("user,host,time") << endl;
      }
    }
    if (!Krun) return false;

    // Update structure - do not set xvasp.str = str_fin or all other
    // information (species, PPs) will be deleted!
    stringstream xstr;
    string filename = aflags.Directory + "/CONTCAR." + _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(_NUM_RELAX_);  // ME20190308
    if (!aurostd::FileExist(filename)) return false;
    aurostd::file2stringstream(filename, xstr);
    xstructure str_fin(xstr, IOVASP_AUTO);
    // Restore species and PP information
    str_fin.species = xvasp.str.species; //ME20190109
    str_fin.species_pp = xvasp.str.species_pp; //ME20190109
    str_fin.species_pp_type = xvasp.str.species_pp_type; //ME20190109
    str_fin.species_pp_version = xvasp.str.species_pp_version; //ME20190109
    str_fin.species_pp_ZVAL = xvasp.str.species_pp_ZVAL; //ME20190109
    str_fin.species_pp_vLDAU = xvasp.str.species_pp_vLDAU; //ME20190109

    xvasp.str = str_fin; //ME20190109
    if(LDEBUG){std::cerr << xvasp.str << std::endl;} // ME20190308
    pflow::fixEmptyAtomNames(xvasp.str,true);  // ME20190308

    // Safeguard for when CONVERT is set in the aflow.in file
    // CONVERT_UNIT_CELL may shift the origin, so not doing it here
    // would lead to inconsistencies when between the supercell creation
    // and the APL/AAPL analysis
    // ME20200102 - should not be necessary anymore when the state is saved,
    // but it's good to convert it anyway to get "nicer" lattice vectors
    if (!vflags.KBIN_VASP_FORCE_OPTION_CONVERT_UNIT_CELL.flag("PRESERVE") &&
        !vflags.KBIN_VASP_FORCE_OPTION_CONVERT_UNIT_CELL.xscheme.empty()) { //ME20190109
      xvasp.str.Standard_Lattice_primitive = false;
      xvasp.str.Standard_Lattice_conventional = false;
      VASP_Convert_Unit_Cell(xvasp, vflags, aflags, fileMessage, aus);
    }

    return Krun;
  }

  void VASP_RunPhonons_APL(_xvasp& xvasp,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _vflags& vflags, ofstream& messageFile, ostream& oss) {
    _xinput xinput(xvasp);
    _xflags xflags(vflags);
    RunPhonons_APL(xinput,AflowIn,aflags,kflags,xflags,messageFile, oss);
  }

  void RunPhonons_APL(_xinput& xinput,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _xflags& xflags, 
      ofstream& messageFile,
      ostream& oss) {
    //ME20200107 - Wrap in a try statement so that faulty APL runs don't kill other post-processing
    try {
      RunPhonons_APL_20181216(xinput,AflowIn,aflags,kflags,xflags,messageFile);
    } catch (aurostd::xerror e) {
      pflow::logger(e.whereFileName(), e.whereFunction(), e.error_message, aflags.Directory, messageFile, oss, _LOGGER_ERROR_);
    }
  }
  void RunPhonons_APL_20181216(_xinput& xinput,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _xflags& xflags, 
      ofstream& messageFile,
      ostream& oss) {

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                               INITIALIZE                                //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    xinput.xvasp.AVASP_arun = true;
    string function = "KBIN::RunPhonons_APL()";  //ME20191029
    // Test
    //if (!(kflags.KBIN_PHONONS_CALCULATION_APL || kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_AAPL)) return; //PN20180705
    if (!(kflags.KBIN_PHONONS_CALCULATION_APL ||
          kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C ||
          kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C ||
          kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C || //PN20180717
          kflags.KBIN_PHONONS_CALCULATION_AAPL)) return; //PN20180705

    //we make certain automatic fixes if we're within our domain, otherwise issue warning/error
    //ME20190109 - OBSOLETE because this doesn't make any sense. The automatic fix that is applied is
    // the VASP version, which can be done anywhere. Moreover, the hostname becomes the name of the node
    //  whenever a job is sent to the queue.
    //  ::_WITHIN_DUKE_ = (aurostd::substring2bool(XHOST.hostname, "nietzsche") || aurostd::substring2bool(XHOST.hostname, "aflowlib") || aurostd::substring2bool(XHOST.hostname, "qrats") || aurostd::substring2bool(XHOST.hostname, "habana") || aurostd::substring2bool(XHOST.hostname, "quser"));

    //determine if we have a consistent mode defined between input and flags
    if(xinput.AFLOW_MODE_VASP){
      if(!xflags.AFLOW_MODE_VASP){
        cerr << "ERROR: KBIN::RunPhonons_APL: mismatch types between xinput(VASP) and xflags(!VASP)" << endl;
        return;
      }
    } else if(xinput.AFLOW_MODE_AIMS){
      if(!xflags.AFLOW_MODE_AIMS){
        cerr << "ERROR: KBIN::RunPhonons_APL: mismatch types between xinput(AIMS) and xflags(!AIMS)" << endl;
        return;
      }
    } //CO20200106 - patching for auto-indenting
    //else if(xinput.AFLOW_MODE_ALIEN){  //alien doesn't have xstr, so we ignore  //[CO20200106 - close bracket for indenting]}
    else {
      cerr << "ERROR: KBIN::RunPhonons_APL: unknown input type" << endl;
      return;
    }

    //CO
    //fix names if necessary, but do not remove pp info, we need mass!
    if(xinput.AFLOW_MODE_VASP){pflow::fixEmptyAtomNames(xinput.xvasp.str,true);}

    // Setup our logger
    apl::Logger logger(messageFile, aflags);
    //logger.setModuleName("PHONONS");  //will rename later

    string _ASTROPT_ = ""; //CO20170601
    string modulename = "";  // ME20200220 - for pflow::logger
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      logger.setModuleName("AAPL");  //CO20170601
      modulename = "AAPL";  // ME20200220
      _ASTROPT_ = _ASTROPT_AAPL_;    //CO20170601
    } else if (kflags.KBIN_PHONONS_CALCULATION_QHA || 
        kflags.KBIN_PHONONS_CALCULATION_QHA_A || 
        kflags.KBIN_PHONONS_CALCULATION_QHA_B || 
        kflags.KBIN_PHONONS_CALCULATION_QHA_C || 
        kflags.KBIN_PHONONS_CALCULATION_SCQHA ||
        kflags.KBIN_PHONONS_CALCULATION_SCQHA_A ||
        kflags.KBIN_PHONONS_CALCULATION_SCQHA_B ||
        kflags.KBIN_PHONONS_CALCULATION_SCQHA_C ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P_A ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P_B ||
        kflags.KBIN_PHONONS_CALCULATION_QHA3P_C) { //PN20180705
      logger.setModuleName("QHA");  //CO20170601
      modulename = "QHA";  // ME20200220
      _ASTROPT_ = _ASTROPT_QHA_;    //CO20170601
    } else {
      logger.setModuleName("APL");  //CO20170601
      modulename = "APL";  // ME20200220
      _ASTROPT_ = _ASTROPT_APL_;    //CO20170601
    }

    logger << "RUNNING..." << apl::endl;

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                      READ PARAMETERS FROM AFLOWIN                       //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    //ME20181019 - Overwrite defaults for CHGCAR, WAVECAR, etc. Only write
    // these files if the user explicitly sets these flags. Otherwise, APL will
    // use too much disk space.
    if (xinput.AFLOW_MODE_VASP) {
      xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.options2entry(AflowIn,_STROPT_+"BADER=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_BADER",xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.isentry && DEFAULT_VASP_FORCE_OPTION_BADER) {
        logger << "Switching OFF BADER for APL calculations (default: OFF)." << apl::endl; //CO20181226 - default OFF
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.options2entry(AflowIn,_STROPT_+"CHGCAR=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_CHGCAR",xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.isentry && DEFAULT_VASP_FORCE_OPTION_CHGCAR) {
        logger << "Switching OFF CHGCAR for APL calculations (default: OFF)." << apl::endl;  //CO20181226 - default OFF
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.options2entry(AflowIn,_STROPT_+"ELF=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_ELF",xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.isentry && DEFAULT_VASP_FORCE_OPTION_ELF) {
        logger << "Switching OFF ELF for APL calculations (default: OFF)." << apl::endl; //CO20181226 - default OFF
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.options2entry(AflowIn,_STROPT_+"WAVECAR=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_WAVECAR",xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.isentry && DEFAULT_VASP_FORCE_OPTION_WAVECAR) {
        logger << "Switching OFF WAVECAR for APL calculations (default: OFF)." << apl::endl;  //CO20181226 - default OFF
      }
    }

    // ME20200427 - added grid option. It takes precedence, so check
    // that the formatting is correct.
    if (xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.isentry) {
      vector<int> kpts;
      aurostd::string2tokens(xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string, kpts, " xX");
      if (kpts.size() != 3) {
        string message = "Incorrect format for KPOINTS_GRID";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
    }

    // Make sure that the formatting for the k-point shift is correct
    if (xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_SHIFT.isentry) {
      vector<int> kpts;
      aurostd::string2tokens(xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_SHIFT.content_string, kpts, " ,;");
      if (kpts.size() != 3) {
        string message = "Incorrect format for KPOINTS_SHIFT";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
    }

    // APL ----------------------------------------------------------------------

    //ME20181026 START

    /***************************** READ PARAMETERS *****************************/

    string USER_ENGINE="", USER_FREQFORMAT="", USER_SUPERCELL="", DOS_MESH_SCHEME="", USER_DOS_METHOD="", USER_TPT="", USER_DC_METHOD=""; //CO20190114 - initialize everything
    string USER_DOS_PROJECTIONS_CART_SCHEME = "", USER_DOS_PROJECTIONS_FRAC_SCHEME = ""; //ME20190625
    string USER_DC_INITLATTICE="", USER_DC_INITCOORDS_FRAC="", USER_DC_INITCOORDS_CART="", USER_DC_INITCOORDS_LABELS="", USER_DC_USERPATH=""; //CO20190114 - initialize everything
    bool USER_DPM=false, USER_AUTO_DISTORTIONS=false, USER_DISTORTIONS_XYZ_ONLY=false, USER_DISTORTIONS_SYMMETRIZE=false, USER_DISTORTIONS_INEQUIVONLY=false, USER_RELAX=false, USER_ZEROSTATE=false, USER_ZEROSTATE_CHGCAR = false; //CO20190114 - initialize everything
    bool USER_HIBERNATE=false, USER_POLAR=false, USER_DC=false, USER_DOS=false, USER_TP=false;  //CO20190114 - initialize everything
    bool USER_DOS_PROJECT = false, USER_RELAX_COMMENSURATE = false, USER_DISPLACEMENTS;  // ME20200213
    double USER_DISTORTION_MAGNITUDE=false, USER_DOS_SMEAR=false, USER_TP_TSTART=false, USER_TP_TEND=false, USER_TP_TSTEP=false;  //CO20190114 - initialize everything  
    int USER_MAXSHELL = 0, USER_MINSHELL = 0, USER_MINATOMS = 0, USER_MINATOMS_RESTRICTED = 0, USER_DC_NPOINTS = 0, USER_DOS_NPOINTS = 0, START_RELAX = 0;  //CO20190114 - initialize everything
    vector<int> USER_DOS_MESH(3);
    vector<xvector<double> > USER_DOS_PROJECTIONS;
    for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.aplflags.size(); i++) {
      const string& key = kflags.KBIN_MODULE_OPTIONS.aplflags[i].keyword;
      logger << (kflags.KBIN_MODULE_OPTIONS.aplflags[i].isentry? "Setting" : "DEFAULT") << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme << apl::endl;
      if (key == "RELAX") {USER_RELAX = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "RELAX_COMMENSURATE") {USER_RELAX_COMMENSURATE = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "HIBERNATE") {USER_HIBERNATE = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "ENGINE") {USER_ENGINE = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "SUPERCELL") {USER_SUPERCELL = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "MINATOMS") {USER_MINATOMS = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_int; continue;}
      if (key == "MINATOMS_RESTRICTED") {USER_MINATOMS_RESTRICTED = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_int; continue;}
      if (key == "MINSHELL") {USER_MINSHELL = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_int; continue;}
      if (key == "POLAR") {USER_POLAR = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "DMAG") {USER_DISTORTION_MAGNITUDE = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_double; continue;}
      if (key == "DXYZONLY") {USER_DISTORTIONS_XYZ_ONLY = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "DSYMMETRIZE") {USER_DISTORTIONS_SYMMETRIZE = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "DINEQUIV_ONLY") {USER_DISTORTIONS_INEQUIVONLY = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;} //CO20190131
      // Special case: DPM can be true, false, or empty
      if (key == "DPM") {
        USER_DPM = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option;
        USER_AUTO_DISTORTIONS=(!kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme.empty() && (kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme[0] == 'A' || kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme[0] == 'a')); //CO20190131
        continue;
      }
      if (key == "ZEROSTATE") {USER_ZEROSTATE = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "ZEROSTATE_CHGCAR") {USER_ZEROSTATE_CHGCAR = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}  //ME20191029
      if (key == "FREQFORMAT") {USER_FREQFORMAT = aurostd::toupper(kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme); continue;}
      if (key == "DC") {USER_DC = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "DCPATH") {USER_DC_METHOD = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DCPOINTS") {USER_DC_NPOINTS = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_int; continue;}
      if (key == "DCINITCOORDSFRAC") {USER_DC_INITCOORDS_FRAC = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DCINITCOORDSCART") {USER_DC_INITCOORDS_CART = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DCINITCOORDSLABELS") {USER_DC_INITCOORDS_LABELS = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DCUSERPATH") {USER_DC_USERPATH = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DOS") {USER_DOS = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "DOSMESH") {DOS_MESH_SCHEME = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DOSMETHOD") {USER_DOS_METHOD = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
      if (key == "DOSSMEAR") {USER_DOS_SMEAR = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_double; continue;}
      if (key == "DOSPOINTS") {USER_DOS_NPOINTS = kflags.KBIN_MODULE_OPTIONS.aplflags[i].content_int; continue;}
      if (key == "DOS_PROJECT") {USER_DOS_PROJECT = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}  // ME20200213
      if (key == "DOSPROJECTIONS_CART") {USER_DOS_PROJECTIONS_CART_SCHEME = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}  // ME20190625
      if (key == "DOSPROJECTIONS_FRAC") {USER_DOS_PROJECTIONS_FRAC_SCHEME = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}  // ME20190625
      if (key == "TP") {USER_TP = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "DISPLACEMENTS") {USER_DISPLACEMENTS = kflags.KBIN_MODULE_OPTIONS.aplflags[i].option; continue;}
      if (key == "TPT") {USER_TPT = kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme; continue;}
    }

    /***************************** CHECK PARAMETERS *****************************/

    string message;

    //ME20190313 START
    // Do not relax with --generate_aflowin_only option
    if (XHOST.GENERATE_AFLOWIN_ONLY && USER_RELAX) {
      USER_RELAX = false;
      logger << apl::warning << "RELAX will be switched OFF for generate_aflowin_only." << apl::endl;
    }
    //ME20190313 END
    // Relax structure
    if (USER_RELAX) {
      START_RELAX = 1;
      if(xinput.AFLOW_MODE_VASP){
        // Check if the structure has already been relaxed
        for (int i = 1; i <= _NUM_RELAX_; i++) {
          string contcar = aflags.Directory + "/CONTCAR." + _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i);
          if (aurostd::EFileExist(contcar) || aurostd::FileExist(contcar)) {  // ME20200103 - also look for uncompressed files
            START_RELAX++;
          } else {
            break;
          }
        }
        if (START_RELAX == _NUM_RELAX_ + 1) {
          logger << "Structure has already been relaxed. Relaxation will be skipped." << apl::endl;
          USER_RELAX = false;
        } else if (START_RELAX != 1) {
          logger << "APL has already performed " << (START_RELAX + 1) << " relaxations.";
          logger << "Number of relaxations remaining: " << (_NUM_RELAX_ - START_RELAX + 1) << "." << apl::endl;
        }
      } else {
        USER_RELAX = false;
        logger << apl::warning << "RELAX option only supported for VASP. Relaxations will be skipped." << apl::endl;
      }
    }

    // Correct user engine
    if (USER_ENGINE == "GSA") {
      logger << "The Generalized Supercell Approach (GSA) is deprecated - replaced with the Direct Method (DM)." << apl::endl;
      USER_ENGINE = "DM";
    }
    if ((USER_ENGINE != "DM") && (USER_ENGINE != "LR")) {
      message = "Wrong setting in " + _ASTROPT_ + "ENGINE. Use either DM or LR. ";
      message += "See README_AFLOW_APL.TXT for more information.";
      //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
      throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
    }
    //ME20191029
    if (USER_ZEROSTATE_CHGCAR) {
      if (USER_ENGINE == "DM") {
        logger << "ZEROSTATE_CHGCAR requires the calculation of the undistorted supercell. ZEROSTATE will be switched on." << apl::endl;
        USER_ZEROSTATE = true;
      } else if (USER_ENGINE == "LR") {
        logger << "ZEROSTATE_CHGCAR cannot be used with Linear Response calculations and will be switched off." << apl::endl;
        USER_ZEROSTATE_CHGCAR = false;
      }
    }

    // SUPERCELL
    // Correct MINATOMS if restricted
    if (kflags.KBIN_MODULE_OPTIONS.minatoms_restricted) USER_MINATOMS = USER_MINATOMS_RESTRICTED;

    vector<string> tokens;
    // Check supercell settings
    if (!USER_SUPERCELL.empty()) {
      tokens.clear();
      apl::tokenize(USER_SUPERCELL, tokens, string(" xX"));
      if (tokens.size() != 3) {
        message = "Wrong setting in " + _ASTROPT_ + "SUPERCELL. ";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }
    }

    // ME20200102 - BEGIN
    // Store supercell generation parameters in xoption.
    aurostd::xoption supercell_opts;
    if (kflags.KBIN_MODULE_OPTIONS.supercell_method[0]) {
      supercell_opts.push_attached("SUPERCELL::METHOD", "SUPERCELL");
      supercell_opts.push_attached("SUPERCELL::VALUE", USER_SUPERCELL);
    } else if (kflags.KBIN_MODULE_OPTIONS.supercell_method[1]) {
      if (kflags.KBIN_MODULE_OPTIONS.minatoms_restricted) {
        supercell_opts.push_attached("SUPERCELL::METHOD", "MINATOMS_RESTRICTED");
        supercell_opts.push_attached("SUPERCELL::VALUE", aurostd::utype2string<int>(USER_MINATOMS_RESTRICTED));
      } else {
        supercell_opts.push_attached("SUPERCELL::METHOD", "MINATOMS");
        supercell_opts.push_attached("SUPERCELL::VALUE", aurostd::utype2string<int>(USER_MINATOMS));
      }
    } else if (kflags.KBIN_MODULE_OPTIONS.supercell_method[2]) {
      supercell_opts.push_attached("SUPERCELL::METHOD", "SHELLS");
      supercell_opts.push_attached("SUPERCELL::VALUE", aurostd::utype2string<int>(USER_MAXSHELL));
    } else if (kflags.KBIN_MODULE_OPTIONS.supercell_method[3]) {
      supercell_opts.push_attached("SUPERCELL::METHOD", "SHELLS");
      supercell_opts.push_attached("SUPERCELL::VALUE", aurostd::utype2string<int>(USER_MINSHELL));
    } else {
      message = "Could not determine supercell method.";
      aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
    }
    supercell_opts.flag("SUPERCELL::VERBOSE", true);  // Use verbose output for supercell construction
    // ME20200102 - END

    if (USER_DC) {
      if (USER_DC_METHOD == "LATTICE") {
        //USER_DC_INITLATTICE = xinput.getXStr().bravais_lattice_variation_type;  // OBSOLETE ME20200117 - this will be determined by the phonon dispersion calculator
      } else if (USER_DC_METHOD == "MANUAL") {
        // Make sure that the number of coordinates and labels agree
        tokens.clear();
        if (!USER_DC_INITCOORDS_FRAC.empty()) {
          apl::tokenize(USER_DC_INITCOORDS_FRAC, tokens, string(" ;"));
        } else {
          apl::tokenize(USER_DC_INITCOORDS_CART, tokens, string(" ;"));
        }
        uint ncoords = tokens.size();
        tokens.clear();
        apl::tokenize(USER_DC_INITCOORDS_LABELS, tokens, string(" ,;"));  //ME20190427 - also break along semicolon
        if (tokens.size() != ncoords) {
          message = "Mismatch between the number of points and the number of labels for the phonon dispersions. ";
          message += "Check the parameters DCINITCOORDS" + string(USER_DC_INITCOORDS_FRAC.empty()?"CART":"FRAC") + " and DCINITCOORDSLABELS.";
          message += "See README_AFLOW_APL.TXT for more information.";
          //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
        }
      } else {
        message = "Wrong setting in " + _ASTROPT_ + "DCPATH. Use either LATTICE or MANUAL. ";
        message += "See README_AFLOW_APL.TXT for more information.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
    }

    // DOS
    if (USER_DOS || USER_TP) {  //ME20190423
      tokens.clear();
      if (USER_DOS_METHOD != "LT" && USER_DOS_METHOD != "RS") {
        message = "Wrong setting in " + _ASTROPT_ + "DOSMETHOD. Use either LT or RS. ";
        message += "See README_AFLOW_APL.TXT for more information.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }
      if ((USER_DOS_METHOD == "RS") && (USER_DOS_SMEAR < _ZERO_TOL_)) {
        logger << apl::warning << "Smearing value for DOS not set or set to zero. ";
        logger << "APL will overwrite the smearing value to 0.05 eV." << apl::endl;
        USER_DOS_SMEAR = 0.05;
      }
      apl::tokenize(DOS_MESH_SCHEME, tokens, string(" xX"));
      if (tokens.size() != 3) {
        message = "Wrong setting in " + _ASTROPT_ + "DOSMESH. ";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      } else {
        USER_DOS_MESH[0] = aurostd::string2utype<int>(tokens[0]);
        USER_DOS_MESH[1] = aurostd::string2utype<int>(tokens[1]);
        USER_DOS_MESH[2] = aurostd::string2utype<int>(tokens[2]);
      }
      // ME20190625 - projected DOS
      // ME20200213 - now has fully atom projected DOS (use zero vector to indicate)
      if (USER_DOS_PROJECT) {
        if (!USER_DOS_PROJECTIONS_CART_SCHEME.empty() || !USER_DOS_PROJECTIONS_FRAC_SCHEME.empty()) {
          if (!USER_DOS_PROJECTIONS_CART_SCHEME.empty() && !USER_DOS_PROJECTIONS_FRAC_SCHEME.empty()) {
            message = "Ambiguous input in APL DOS projections. ";
            message += "Choose between DOSPROJECTIONS_CART and DOSPROJECTIONS_FRAC.";
            //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_AMBIGUOUS_);
          }
          string projscheme = "";
          if (!USER_DOS_PROJECTIONS_CART_SCHEME.empty()) projscheme = USER_DOS_PROJECTIONS_CART_SCHEME;
          else projscheme = USER_DOS_PROJECTIONS_FRAC_SCHEME;
          aurostd::string2tokens(projscheme, tokens, "; ");
          for (uint i = 0; i < tokens.size(); i++) {
            vector<double> proj;
            aurostd::string2tokens(tokens[i], proj, ", ");
            if (proj.size() == 3) {
              USER_DOS_PROJECTIONS.push_back(aurostd::vector2xvector<double>(proj));
            } else {
              message = "Wrong setting in " + _ASTROPT_ + "DOSPROJECTIONS_";
              message += string(USER_DOS_PROJECTIONS_CART_SCHEME.empty()?"FRAC":"CART") + ". ";
              message += "See README_AFLOW_APL.TXT for the correct format.";
              throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
            }
          }
        } else {
          xvector<double> proj(3);
          USER_DOS_PROJECTIONS.push_back(proj);
        }
      }
    }

    // TPT
    if (USER_TP) {
      tokens.clear();
      apl::tokenize(USER_TPT, tokens, string(" :"));
      if (tokens.size() != 3) {
        message = "Wrong setting in " + _ASTROPT_ + "TPT. ";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }
      USER_TP_TSTART = aurostd::string2utype<double>(tokens[0]);
      USER_TP_TEND = aurostd::string2utype<double>(tokens[1]);
      USER_TP_TSTEP = aurostd::string2utype<double>(tokens[2]);
    }

    /****************************** OUTPUT SUMMARY ******************************/

    logger << "Parameters for the Automatic Phonon Library successfully read." << apl::endl;
    logger << "The structure will " << (USER_RELAX?"":"NOT ") << "be relaxed before running APL." << apl::endl;
    logger << "The hibernate feature is switched " << (USER_HIBERNATE?"ON":"OFF") << "." << apl::endl;
    logger << "Phonons will be calculated using the " << (USER_ENGINE=="DM"?"Direct":"Linear Response") << " Method." << apl::endl;

    if (USER_ENGINE == "DM") {
      logger << "The distortion magnitude will be " << USER_DISTORTION_MAGNITUDE << " Angstrom." << apl::endl;
      if (USER_DISTORTIONS_XYZ_ONLY) {
        logger << "Only distortions along the lattice vectors will be used." << apl::endl;
      } else {
        logger << "Atoms will be distorted along the lattice vectors, face diagonals, and body diagonals." << apl::endl;
      }
      if (USER_DISTORTIONS_SYMMETRIZE) {
        logger << "Non-symmetric distortion directions will be determined for each site." << apl::endl;
      } else {
        logger << "Distortions will be generated in three independent directions." << apl::endl;
      }
      if (USER_DISTORTIONS_INEQUIVONLY) { //CO20190131
        logger << "Distortion directions will be determined for inequivalent site only." << apl::endl;
      } else {
        logger << "Distortion directions will be determined for ALL site." << apl::endl;
      }
      if (USER_AUTO_DISTORTIONS) {
        logger << "Positive/negative distortion directions will be determined for each site." << apl::endl; 
      } else if (USER_DPM) {
        logger << "Distortions will be generated in both the positive and negative direction." << apl::endl;
      } else {
        logger << apl::warning << "Distortions will only be generated in the positive direction - this is NOT recommended." << apl::endl;
      }
      logger << "Forces from the undistored state will " << (USER_ZEROSTATE?"":"NOT ") << "be used." << apl::endl;
      logger << "The CHGCAR file of the undistorted state will " << (USER_ZEROSTATE_CHGCAR?"":"NOT ") << "be used for distorted cells." << apl::endl;  //ME20191029
    }

    logger << "Polar corrections will " << (USER_POLAR?"":"NOT ") << "be employed." << apl::endl;
    logger << "Frequencies will be returned in this format: " << USER_FREQFORMAT << "." << apl::endl;

    logger << "The supercell will be built using ";
    if (kflags.KBIN_MODULE_OPTIONS.supercell_method[0]) {
      logger << "the dimensions " << USER_SUPERCELL << "." << apl::endl;
    } else if (kflags.KBIN_MODULE_OPTIONS.supercell_method[1]) {
      logger << "at least " << USER_MINATOMS << " atoms." << apl::endl;
    } else if (kflags.KBIN_MODULE_OPTIONS.supercell_method[2]) {
      logger << "at most " << USER_MAXSHELL << " shells." << apl::endl;
    } else {
      logger << "at least " << USER_MINSHELL << " shells." << apl::endl;
    }

    if (USER_DC) {
      logger << "Phonon dispersion curves will be calculated ";
      if (USER_DC_METHOD == "LATTICE") {
        logger << "using the default path of the lattice (see DOI 10.1016/j.commatsci.2010.05.010). ";
      } else {
        logger << "along the " << (USER_DC_INITCOORDS_FRAC.empty()?"Cartesian":"fractional") << " coordinates ";
        logger << "[" << (USER_DC_INITCOORDS_FRAC.empty()?USER_DC_INITCOORDS_CART:USER_DC_INITCOORDS_FRAC) << "].";
      }
      logger << " Each subpath will be divided into " << USER_DC_NPOINTS << " points." << apl::endl;
    } else {
      logger << "Phonon dispersion curves will NOT be calculated." << apl::endl;
    }

    if (USER_DOS || USER_TP) {  //ME20190423
      logger << "Phonon DOS will be calculated using the ";
      logger << (USER_DOS_METHOD == "LT"?"Linear Tetrahedron":"Root Sampling") << " method ";
      logger << "along a " << USER_DOS_MESH[0] << "x" << USER_DOS_MESH[1] << "x" << USER_DOS_MESH[2];
      logger << " mesh with " << USER_DOS_NPOINTS << " bins.";
      if (USER_DOS_METHOD == "RS")
        logger << " A smearing value of " << USER_DOS_SMEAR << " eV will be used.";
      //ME20190626 - projected DOS
      if ((USER_DOS_PROJECTIONS.size() == 0) || (USER_DOS_METHOD == "RS")) {
        logger << " Projected phonon DOS will NOT be calculated.";
      } else {
        logger << " Projected phonon DOS will be calculated along the "
          << (USER_DOS_PROJECTIONS_CART_SCHEME.empty()?"fractional":"Cartesian") << " directions ";
        for (uint i = 0; i < USER_DOS_PROJECTIONS.size(); i++) {
          logger << "[";
          for (int j = 1; j < 4; j++) logger << USER_DOS_PROJECTIONS[i][j] << ((j < 3)?", ":"");
          logger << "]" << ((i < USER_DOS_PROJECTIONS.size() - 1)?", ":".");
        }
      }
      logger << apl::endl;
    } else {
      logger << "Phonon DOS will NOT be calculated." << apl::endl;
    }

    if (USER_TP) {
      logger << "Thermodynamic properties will be calculated between ";
      logger << USER_TP_TSTART << " K and " << USER_TP_TEND << " K ";
      logger << "in " << USER_TP_TSTEP << " K steps." << apl::endl;
    } else {
      logger << "Thermodynamic properties will NOT be calculated." << apl::endl;
    }
    //ME20181026 END

    // AAPL ----------------------------------------------------------------------

    //ME20181027 START

    /***************************** READ PARAMETERS *****************************/

    string USER_BTE;
    bool USER_TCOND, USER_ISOTOPE, USER_BOUNDARY, USER_CUMULATIVEK, USER_AAPL_FOURTH_ORDER;
    double USER_NANO_SIZE, USER_EPS_SUM, USER_AAPL_MIX, USER_TCT_TSTART, USER_TCT_TEND, USER_TCT_TSTEP;
    int USER_AAPL_MAX_ITER, USER_KPPRA_AAPL = -1;  //ME20190408 - Added KPPRA_AAPL
    vector<double> USER_CUTOFF_DISTANCE(2);
    vector<int> USER_CUTOFF_SHELL(2), USER_THERMALGRID(3);
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      USER_TCOND = true;
      string CUTOFF_SCHEME, SHELL_SCHEME, THERMALGRID_SCHEME, TCT_SCHEME;
      for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.aaplflags.size(); i++) {
        const string& key = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].keyword;
        logger << (kflags.KBIN_MODULE_OPTIONS.aaplflags[i].isentry? "Setting" : "DEFAULT") << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme << apl::endl;
        if (key == "BTE") {USER_BTE = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme; continue;}
        if (key == "FOURTH_ORDER") {USER_AAPL_FOURTH_ORDER = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].option; continue;}
        if (key == "CUT_RAD") {CUTOFF_SCHEME = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme; continue;}
        if (key == "CUT_SHELL") {SHELL_SCHEME = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme; continue;}
        if (key == "THERMALGRID") {THERMALGRID_SCHEME = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme; continue;}
        if (key == "TCT") {TCT_SCHEME = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme; continue;}
        if (key == "SUMRULE") {USER_EPS_SUM = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].content_double; continue;}
        if (key == "SUMRULE_MAX_ITER") {USER_AAPL_MAX_ITER = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].content_int; continue;}
        if (key == "MIXING_COEFFICIENT") {USER_AAPL_MIX = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].content_double; continue;}
        if (key == "ISOTOPE") {USER_ISOTOPE = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].option; continue;}
        if (key == "BOUNDARY") {USER_BOUNDARY = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].option; continue;}
        if (key == "CUMULATIVEK") {USER_CUMULATIVEK = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].option; continue;}
        if (key == "NANO_SIZE") {USER_NANO_SIZE = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].content_double; continue;}
        if (key == "KPPRA_AAPL") {USER_KPPRA_AAPL = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].content_int; continue;}  //ME20190408
      }

      /***************************** CHECK PARAMETERS *****************************/

      // Correct BTE
      if (USER_BTE != "RTA" && USER_BTE != "FULL") {
        message = "Wrong setting in " + _ASTROPT_ + "BTE. Use either RTA or FULL.";
        message += "See README_AFLOW_APL.TXT for more information.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_ILLEGAL_);
      }

      vector<string> tokens;
      // CUT_SHELL and CUT_RAD
      bool defaults = (!kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[0] && !kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[1]);
      if (defaults || kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[0]) {
        tokens.clear();
        apl::tokenize(CUTOFF_SCHEME, tokens, string(" ,"));
        if (tokens.size() < 1) {
          message = "Not enought entries in " + _ASTROPT_ + "CUT_RAD. ";
          message += "See README_AFLOW_APL.TXT for more information.";
          //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
        } else if (tokens.size() > 2) {
          logger << apl::warning << "Too many entries for " << _ASTROPT_ << "CUT_RAD. ";
          logger << "Excess entries will be ignored." << apl::endl;
        }
        USER_CUTOFF_DISTANCE[0] = aurostd::string2utype<double>(tokens[0]);
        if (USER_AAPL_FOURTH_ORDER) {
          if (tokens.size() == 1) {
            logger << apl::warning << "Only one entry found for the cutoff radius. ";
            logger << "3rd and 4th order anharmonic IFCs will use the same value." << apl::endl;
            USER_CUTOFF_DISTANCE[1] = USER_CUTOFF_DISTANCE[0];
          } else {
            USER_CUTOFF_DISTANCE[1] = aurostd::string2utype<double>(tokens[1]);
          }
        }
      }

      if (defaults || kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[1]) {
        tokens.clear();
        apl::tokenize(SHELL_SCHEME, tokens, string(" ,"));
        if (tokens.size() < 1) {
          message = "Not enought entries in " + _ASTROPT_ + "CUT_SHELL. ";
          message += "See README_AFLOW_APL.TXT for more information.";
          //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
        } else if (tokens.size() > 2) {
          logger << apl::warning << "Too many entries for " << _ASTROPT_ << "CUT_SHELL. ";
          logger << "Excess entries will be ignored." << apl::endl;
        }
        USER_CUTOFF_SHELL[0] = aurostd::string2utype<int>(tokens[0]);
        if (USER_AAPL_FOURTH_ORDER) {
          if (tokens.size() == 1) {
            logger << apl::warning << "Only one entry found for the number of coordination shells. ";
            logger << "3rd and 4th order anharmonic IFCs will use the same value." << apl::endl;
            USER_CUTOFF_SHELL[1] = USER_CUTOFF_SHELL[0];
          } else {
            USER_CUTOFF_SHELL[1] = aurostd::string2utype<int>(tokens[1]);
          }
        }
      }
      // If only one parameter is set in the aflow.in file, unset the other
      if (kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[0] != kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[1]) {
        if (!kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[0]) USER_CUTOFF_DISTANCE.assign(2, 0.0);
        if (!kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[1]) USER_CUTOFF_SHELL.assign(2, 0);
      }

      // THERMALGRID
      tokens.clear();
      apl::tokenize(THERMALGRID_SCHEME, tokens, string(" xX"));
      if (tokens.size() == 3) {
        USER_THERMALGRID[0] = aurostd::string2utype<int>(tokens[0]);
        USER_THERMALGRID[1] = aurostd::string2utype<int>(tokens[1]);
        USER_THERMALGRID[2] = aurostd::string2utype<int>(tokens[2]);
      } else {
        message = "Wrong setting in " + _ASTROPT_ + "THERMALGRID. ";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }

      // TCT
      tokens.clear();
      apl::tokenize(TCT_SCHEME, tokens, string(" :"));
      if (tokens.size() == 3) {
        USER_TCT_TSTART = aurostd::string2utype<double>(tokens[0]);
        USER_TCT_TEND = aurostd::string2utype<double>(tokens[1]);
        USER_TCT_TSTEP = aurostd::string2utype<double>(tokens[2]);
        if (USER_TCT_TSTART == 0) {
          logger << apl::warning << "Thermal conductivity is infinite at 0 K and will be skipped." << apl::endl;
          USER_TCT_TSTART += USER_TCT_TSTEP;
        }
      } else {
        message = "Wrong setting in " + _ASTROPT_ + "TCT. ";
        message += "See README_AFLOW_APL.TXT for the correct format.";
        //throw apl::APLRuntimeError(message);  OBSOLETE ME20191029 - replace with xerror
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, message, _INPUT_NUMBER_);
      }
      // BOUNDARY and CUMULATIVEK
      if (USER_BOUNDARY && USER_CUMULATIVEK) {
        USER_CUMULATIVEK = false;
        logger << apl::warning << "Both boundary effects and cumulative thermal conductivity cannot be ";
        logger << "set at the same time. Cumulative thermal conductivity has been switched off." << apl::endl;
      }

      /****************************** OUTPUT SUMMARY ******************************/

      logger << "Parameters for the Automatic Anharmonic Phonon Library successfully read." << apl::endl;
      logger << "Four-phonon processes will " << (USER_AAPL_FOURTH_ORDER?"":"NOT ") << "be included in the calculations." << apl::endl;

      defaults = (!kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[0] && !kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[1]);
      if (defaults || kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[0]) {
        logger << "The cutoff to compute the 3rd order anharmonic IFCs will be ";
        logger << USER_CUTOFF_DISTANCE[0] << " Angstrom." << apl::endl;
        if (USER_AAPL_FOURTH_ORDER) {
          logger << "The cutoff to compute the 4th order anharmonic IFCs will be ";
          logger << USER_CUTOFF_DISTANCE[1] << " Angstrom." << apl::endl;
        }
      }
      if (defaults || kflags.KBIN_MODULE_OPTIONS.cut_rad_shell[1]) {
        logger << "The calculation of 3rd order anharmonic IFCs will consider up to ";
        logger << USER_CUTOFF_SHELL[0] << " coordination shells." << apl::endl;
        if (USER_AAPL_FOURTH_ORDER) {
          logger << "The calculation of 4th order anharmonic IFCs will consider up to ";
          logger << USER_CUTOFF_SHELL[1] << " coordination shells." << apl::endl;
        }
      }

      if (USER_KPPRA_AAPL > 0) logger << "AAPL will use a KPPRA of " << USER_KPPRA_AAPL << " for static calculations." << apl::endl;  //ME20190408

      logger << "Anharmonic IFCs will be calculated with a convergence criterion of " << USER_EPS_SUM << "." << apl::endl;
      logger << "A mixing coefficient of " << USER_AAPL_MIX << " will be used." << apl::endl;
      logger << "Anharmonic IFCs need to be converged within " << USER_AAPL_MAX_ITER << " iterations." << apl::endl;

      logger << "Thermal conductivity will be calculated between ";
      logger << USER_TCT_TSTART << " K and " << USER_TCT_TEND << "K ";
      logger << "in " << USER_TCT_TSTEP << " K steps." << apl::endl;

      logger << "The Boltzmann Transport Equation will be solved using ";
      if (USER_BTE == "RTA") {
        logger << "the Relaxation Time Approximation Approximation (RTA)." << apl::endl;
      } else {
        logger << "an iterative scheme." << apl::endl;
      }
      logger << "The equation will be solved using the tetrahedron method along a ";
      logger << USER_THERMALGRID[0] << "x" << USER_THERMALGRID[1] << "x" << USER_THERMALGRID[2] << " q-point mesh." << apl::endl;
      logger << "Isotope effects will " << (USER_ISOTOPE?"":"NOT ") << "be included." << apl::endl;
      if (USER_BOUNDARY || USER_CUMULATIVEK) {
        logger << "Boundary effects will be included via ";
        if (USER_BOUNDARY) {
          logger << "boundary scattering with a grain size of ";
        } else {
          logger << "cumulative thermal conductivity and a mean free path of at most ";
        }
        logger << USER_NANO_SIZE << " nm." << apl::endl;
      } else {
        logger << "Boundary effects will NOT be included." << apl::endl;
      }
    } else {
      USER_TCOND = false;
      logger << "Anharmonic force constants and thermal conductivity will NOT be calculated." << apl::endl;
    }
    //ME20181027 STOP

    // QHA ----------------------------------------------------------------------

    //  //PN QUASI-HARMONIC START
    aurostd::xoption CALCULATE_GROUPVELOCITY_OPTION; CALCULATE_GROUPVELOCITY_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_OPTION; CALCULATE_GRUNEISEN_OPTION.option = false;
    aurostd::xoption CALCULATE_DISPLACEMENTS_OPTION; CALCULATE_DISPLACEMENTS_OPTION.option = false;
    aurostd::xoption CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option = false;
    aurostd::xoption CALCULATE_EOS_OPTION; CALCULATE_EOS_OPTION.option = false;
    aurostd::xoption CALCULATE_EOS_SUBDIRECTORIES_OPTION; CALCULATE_EOS_SUBDIRECTORIES_OPTION.option = false;
    aurostd::xoption EDOS_ACURATE_OPTION; EDOS_ACURATE_OPTION.option = false; //PN20180705
    aurostd::xoption INCLUDE_ELE_OPTION;  INCLUDE_ELE_OPTION.option = false; //PN20180705
    //Anisotropic Gruneisen and EOS //PN20180705
    //in the a-direction //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_A_OPTION; CALCULATE_GRUNEISEN_A_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    aurostd::xoption GP_DISTORTION_OPTION; GP_DISTORTION_OPTION.xscheme = "0.03"; double GP_DISTORTION = 0.03; //PN20180705

    //in the b-direction //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_B_OPTION; CALCULATE_GRUNEISEN_B_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //in the c-direction //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_C_OPTION; CALCULATE_GRUNEISEN_C_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION; CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //SC-QHA //PN20180705
    aurostd::xoption CALCULATE_SCQHA_OPTION; CALCULATE_SCQHA_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    //QHA3P option
    aurostd::xoption CALCULATE_QHA3P_OPTION; CALCULATE_QHA3P_OPTION.option = false; //PN20180705

    //Anisotropic SCQHA EOS //PN20180705
    //in the a-direction //PN20180705
    aurostd::xoption CALCULATE_SCQHA_A_OPTION; CALCULATE_SCQHA_A_OPTION.option = false; //PN20180705
    aurostd::xoption SCQHA_DISTORTION_OPTION; SCQHA_DISTORTION_OPTION.xscheme = "3.0"; double SCQHA_DISTORTION = 3.0; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //in the b-direction //PN20180705
    aurostd::xoption CALCULATE_SCQHA_B_OPTION; CALCULATE_SCQHA_B_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //in the c-direction //PN20180705
    aurostd::xoption CALCULATE_SCQHA_C_OPTION; CALCULATE_SCQHA_C_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION; CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option = false; //PN20180705

    //QHA3P a direction
    aurostd::xoption CALCULATE_QHA3P_A_OPTION; CALCULATE_QHA3P_A_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_A_SUBDIRECTORIES_OPTION; CALCULATE_QHA3P_A_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_B_OPTION; CALCULATE_QHA3P_B_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_B_SUBDIRECTORIES_OPTION; CALCULATE_QHA3P_B_SUBDIRECTORIES_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_C_OPTION; CALCULATE_QHA3P_C_OPTION.option = false; //PN20180705
    aurostd::xoption CALCULATE_QHA3P_C_SUBDIRECTORIES_OPTION; CALCULATE_QHA3P_C_SUBDIRECTORIES_OPTION.option = false; //PN20180705


    //QHA, QHA3P and SCQHA options initializing from previous options
    CALCULATE_GRUNEISEN_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA;
    CALCULATE_GRUNEISEN_A_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA_A;
    CALCULATE_GRUNEISEN_B_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA_B;
    CALCULATE_GRUNEISEN_C_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA_C;

    CALCULATE_SCQHA_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA;
    CALCULATE_SCQHA_A_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA_A;
    CALCULATE_SCQHA_B_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA_B;
    CALCULATE_SCQHA_C_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_SCQHA_C;

    CALCULATE_QHA3P_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P;
    CALCULATE_QHA3P_A_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P_A;
    CALCULATE_QHA3P_B_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P_B;
    CALCULATE_QHA3P_C_OPTION.option=kflags.KBIN_PHONONS_CALCULATION_QHA3P_C;

    // different types of fitting options for EOS calculations
    // (1) BM1 => Murnaghan EOS
    // (2) BM2 => Birch-Murnaghan 3rd-order EOS
    // (3) BM3 => Birch-Murnaghan 4th-order EOS
    //[OBSOLETE PN20180705]aurostd::xoption GP_VOL_DISTORTION_OPTION; GP_VOL_DISTORTION_OPTION.xscheme = "0.03"; double GP_VOL_DISTORTION = 0.03;
    aurostd::xoption USER_PROJECTION_DIR_OPTION; USER_PROJECTION_DIR_OPTION.xscheme = "1:1:1"; vector<double> directions(3, 0); directions[0] = 1; directions[1] = 1; directions[2] = 1;   // 3 Miller indices
    aurostd::xoption CUTOFF_FREQ_OPTION; CUTOFF_FREQ_OPTION.xscheme="1e-5"; double CUTOFF_FREQ = 1e-5;  //in amu
    aurostd::xoption EOS_DISTORTION_RANGE_OPTION; EOS_DISTORTION_RANGE_OPTION.xscheme = "-3:6:1"; double EOS_DISTORTION_START = -3; double EOS_DISTORTION_END = 6; double EOS_DISTORTION_DISTORTION_INC=1; //PN20180705
    aurostd::xoption EOS_STATIC_KPPRA_OPTION; EOS_STATIC_KPPRA_OPTION.xscheme = "10000"; int EOS_STATIC_KPPRA = 10000; //PN20180705
    aurostd::xoption NEDOS_OPTION; NEDOS_OPTION.xscheme = "5000"; int NEDOS = 5000; //PN20180705
    aurostd::xoption FITTING_TYPE_OPTION; FITTING_TYPE_OPTION.xscheme = "BM1"; string FITTING_TYPE = "BM1";
    aurostd::xoption SCQHA_PDIS_T_OPTION; SCQHA_PDIS_T_OPTION.xscheme = "100,400,600"; std::vector<double> scqha_pdis_T; //PN20180705
    //PN QUASI-HARMONIC END

    //PN PHONON START
    //GROUPVELOCITY=y/n
    CALCULATE_GROUPVELOCITY_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GROUP_VELOCITY=" + "|" + _ASTROPT_APL_OLD_ + "GROUP_VELOCITY="), CALCULATE_GROUPVELOCITY_OPTION.option,  CALCULATE_GROUPVELOCITY_OPTION.xscheme);
    logger << (CALCULATE_GROUPVELOCITY_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "GROUP_VELOCITY=" << (CALCULATE_GROUPVELOCITY_OPTION.option ? "ON" : "OFF") << "." << apl::endl;

    //PN PHONON END

    //PN QUASI-HARMONIC START
    if(!USER_TCOND){
      if(kflags.KBIN_PHONONS_CALCULATION_QHA){
        CALCULATE_GRUNEISEN_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA; //recycle what we parsed earlier
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen parameter will" << ( CALCULATE_GRUNEISEN_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA_A){
        CALCULATE_GRUNEISEN_A_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA_A;
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_A_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen_A parameter will" << ( CALCULATE_GRUNEISEN_A_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA_B){
        CALCULATE_GRUNEISEN_B_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA_B;
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_B_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen_B parameter will" << ( CALCULATE_GRUNEISEN_B_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA_C){
        CALCULATE_GRUNEISEN_C_OPTION.option = kflags.KBIN_PHONONS_CALCULATION_QHA_C;
        logger << _ASTROPT_ << "CALC is" << ( CALCULATE_GRUNEISEN_C_OPTION.option ? "" : " NOT" ) << " set." << apl::endl;
        logger << "The Gruneisen_C parameter will" << ( CALCULATE_GRUNEISEN_C_OPTION.option ? "" : " NOT" ) << " be computed via AFLOW-QHA." << apl::endl;
      }

      //QHA, QHA3P and SCQHA INCLUDE ELECTRONIC OPTION
      if(kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C ||
          kflags.KBIN_PHONONS_CALCULATION_SCQHA|| kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        INCLUDE_ELE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "INCLUDE_ELE=" + "|" + _ASTROPT_ + "INCLUDE_ELE="), INCLUDE_ELE_OPTION.option, INCLUDE_ELE_OPTION.xscheme);
        logger << (INCLUDE_ELE_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "INCLUDE_ELE=" << (INCLUDE_ELE_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      }

      //QHA3P and SCQHA temperature dependent phonon dispersion option
      if(kflags.KBIN_PHONONS_CALCULATION_SCQHA|| kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        SCQHA_PDIS_T_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "SCQHA_PDIS_T=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_PDIS_T="), SCQHA_PDIS_T_OPTION.option, SCQHA_PDIS_T_OPTION.xscheme);
        tokens.clear(); scqha_pdis_T.clear();
        apl::tokenize(SCQHA_PDIS_T_OPTION.content_string, tokens, string(" ,"));
        if (tokens.size() == 0) {
          //ME20191031 - use xerror
          //throw apl::APLRuntimeError("Wrong setting in the "+_ASTROPT_+"SCQHA_PDIS_T. Specify as SCQHA_PDIS_T=-100.0, 300.0, 600.0");
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the"+_ASTROPT_+"SCQHA_PDIS_T. Specify as SCQHA_PDIS_T=-100.0, 300.0, 600.0", _INPUT_ILLEGAL_);
        }
        if(tokens.size()!=0){
          for (uint i=0; i<tokens.size(); i++){
            scqha_pdis_T.push_back(aurostd::string2utype<double>(tokens.at(i)));
          }
        }
      }
      //rectifying possible user QHA-input errors
      if(CALCULATE_GRUNEISEN_OPTION.option){
        CALCULATE_SCQHA_A_OPTION.option=false;
        CALCULATE_SCQHA_B_OPTION.option=false;
        CALCULATE_SCQHA_C_OPTION.option=false;
      } else if(CALCULATE_GRUNEISEN_A_OPTION.option){
        CALCULATE_SCQHA_OPTION.option=false;
        CALCULATE_SCQHA_B_OPTION.option=false;
        CALCULATE_SCQHA_C_OPTION.option=false;
      } else if(CALCULATE_GRUNEISEN_B_OPTION.option){
        CALCULATE_SCQHA_OPTION.option=false;
        CALCULATE_SCQHA_A_OPTION.option=false;
        CALCULATE_SCQHA_C_OPTION.option=false;
      } else if(CALCULATE_GRUNEISEN_C_OPTION.option){
        CALCULATE_SCQHA_OPTION.option=false;
        CALCULATE_SCQHA_A_OPTION.option=false;
        CALCULATE_SCQHA_B_OPTION.option=false;
      }

      //Writing to log
      if(kflags.KBIN_PHONONS_CALCULATION_SCQHA){
        logger << (CALCULATE_SCQHA_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA=" << (CALCULATE_SCQHA_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA_A){
        logger << (CALCULATE_SCQHA_A_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_A=" << (CALCULATE_SCQHA_A_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA_B){
        logger << (CALCULATE_SCQHA_B_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_B=" << (CALCULATE_SCQHA_B_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        logger << (CALCULATE_SCQHA_C_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_C=" << (CALCULATE_SCQHA_C_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      }

      //Writing to log
      if(kflags.KBIN_PHONONS_CALCULATION_QHA3P){
        logger << (CALCULATE_QHA3P_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P=" << (CALCULATE_QHA3P_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA3P_A){
        logger << (CALCULATE_QHA3P_A_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P_A=" << (CALCULATE_QHA3P_A_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA3P_B){
        logger << (CALCULATE_QHA3P_B_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P_B=" << (CALCULATE_QHA3P_B_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      } else if(kflags.KBIN_PHONONS_CALCULATION_QHA3P_C){
        logger << (CALCULATE_QHA3P_C_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "QHA3P_C=" << (CALCULATE_QHA3P_C_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      }

      if(CALCULATE_SCQHA_OPTION.option || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C){
        SCQHA_DISTORTION_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "SCQHA_DISTORTION=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_DISTORTION="), SCQHA_DISTORTION_OPTION.option, SCQHA_DISTORTION_OPTION.xscheme);
        SCQHA_DISTORTION=SCQHA_DISTORTION_OPTION.content_double;
        if (SCQHA_DISTORTION_OPTION.isentry) {
          tokens.clear();
          apl::tokenize(SCQHA_DISTORTION_OPTION.content_string, tokens, string(" "));
          if (tokens.size() != 1) {
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"SCQHA_DISTORTION. Specify as SCQHA_DISTORTION_OPTION=3.0.", _INPUT_ILLEGAL_);
          }
        }
        logger << (SCQHA_DISTORTION_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "SCQHA_DISTORTION=" << SCQHA_DISTORTION << "." << apl::endl;
      }

      if(CALCULATE_GRUNEISEN_OPTION.option || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B || kflags.KBIN_PHONONS_CALCULATION_QHA_C || kflags.KBIN_PHONONS_CALCULATION_SCQHA ||
          kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C || kflags.KBIN_PHONONS_CALCULATION_QHA3P ||
          kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C){

        CUTOFF_FREQ_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "CUTOFF_FREQ=" + "|" + _ASTROPT_APL_OLD_ + "CUTOFF_FREQ="), CUTOFF_FREQ_OPTION.option, CUTOFF_FREQ_OPTION.xscheme); //CO20170601
        CUTOFF_FREQ = CUTOFF_FREQ_OPTION.content_double;
        if (CUTOFF_FREQ_OPTION.isentry) {
          tokens.clear();
          apl::tokenize(CUTOFF_FREQ_OPTION.content_string, tokens, string(" "));
          if (tokens.size() != 1) {
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"CUTOFF_FREQ. Specify as CUTOFF_FREQ=0.01.", _INPUT_ILLEGAL_);
          }
        }
        logger << (CUTOFF_FREQ_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "CUTOFF_FREQ=" << CUTOFF_FREQ_OPTION.content_string << "." << apl::endl;


        CALCULATE_EOS_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "EOS=" + "|" + _ASTROPT_APL_OLD_ + "EOS="), CALCULATE_EOS_OPTION.option, CALCULATE_EOS_OPTION.xscheme); //CO20170601
        logger << (CALCULATE_EOS_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "EOS=" << (CALCULATE_EOS_OPTION.option ? "ON" : "OFF") << "." << apl::endl;

        if ((CALCULATE_EOS_OPTION.option) && (CALCULATE_GRUNEISEN_OPTION.option || kflags.KBIN_PHONONS_CALCULATION_QHA_A || kflags.KBIN_PHONONS_CALCULATION_QHA_B ||
              kflags.KBIN_PHONONS_CALCULATION_QHA_C || kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A ||
              kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C || kflags.KBIN_PHONONS_CALCULATION_QHA3P ||
              kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C))

        {
          EOS_DISTORTION_RANGE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "EOS_DISTORTION_RANGE=" + "|" + _ASTROPT_APL_OLD_ + "EOS_DISTORTION_RANGE="), EOS_DISTORTION_RANGE_OPTION.option, EOS_DISTORTION_RANGE_OPTION.xscheme);
          tokens.clear();
          apl::tokenize(EOS_DISTORTION_RANGE_OPTION.content_string, tokens, string(" :"));
          if (tokens.size() != 3) {
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"EOS_DISTORTION_RANGE. Specify as EOS_DISTORTION_RANGE=-3:6:1.", _INPUT_ILLEGAL_);
          }
          EOS_DISTORTION_START = aurostd::string2utype<double>(tokens.at(0));
          EOS_DISTORTION_END = aurostd::string2utype<double>(tokens.at(1));
          EOS_DISTORTION_DISTORTION_INC = aurostd::string2utype<double>(tokens.at(2));
          logger << (EOS_DISTORTION_RANGE_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "EOS_DISTORTION_RANGE=" << EOS_DISTORTION_RANGE_OPTION.content_string << "." << apl::endl;
          logger << "The EOS properties will be calculated in distortion range <" << EOS_DISTORTION_START << "," << EOS_DISTORTION_END << "," << EOS_DISTORTION_DISTORTION_INC << "." << apl::endl;

          FITTING_TYPE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "FITTING_TYPE=" + "|" + _ASTROPT_APL_OLD_ + "FITTING_TYPE="), FITTING_TYPE_OPTION.option, FITTING_TYPE_OPTION.xscheme); //CO20170601
          FITTING_TYPE = FITTING_TYPE_OPTION.content_string;
          if (FITTING_TYPE_OPTION.isentry) {
            tokens.clear();
            apl::tokenize(FITTING_TYPE_OPTION.content_string, tokens, string(" "));
            if (tokens.size() != 1) {
              throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"FITTING_TYPE. Specify as FITTING_TYPE=BM2.", _INPUT_ILLEGAL_);
            }
          }
          logger << (FITTING_TYPE_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "FITTING_TYPE=" << FITTING_TYPE_OPTION.content_string << "." << apl::endl;
          logger << "EOS fitting type found = " << FITTING_TYPE << "." << apl::endl;

          EOS_STATIC_KPPRA_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "EOS_STATIC_KPPRA=" + "|" + _ASTROPT_APL_OLD_ + "EOS_STATIC_KPPRA="), EOS_STATIC_KPPRA_OPTION.option, EOS_STATIC_KPPRA_OPTION.xscheme);
          EOS_STATIC_KPPRA = EOS_STATIC_KPPRA_OPTION.content_int;
          if(CALCULATE_GRUNEISEN_OPTION.option){
            if (EOS_STATIC_KPPRA_OPTION.isentry) {
              tokens.clear();
              apl::tokenize(EOS_STATIC_KPPRA_OPTION.content_string, tokens, string(" "));
              if (tokens.size() != 1) {
                throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"EOS_STATIC_KPPRA. Specify as EOS_STATIC_KPPRA=10000.", _INPUT_ILLEGAL_);
              }
            }
            logger << (EOS_STATIC_KPPRA_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "EOS_STATIC_KPPRA=" << EOS_STATIC_KPPRA_OPTION.content_string << "." << apl::endl;
          }
          NEDOS_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "NEDOS=" + "|" + _ASTROPT_APL_OLD_ + "NEDOS="), NEDOS_OPTION.option, NEDOS_OPTION.xscheme);
          NEDOS = NEDOS_OPTION.content_int;
          if (NEDOS_OPTION.isentry) {
            tokens.clear();
            apl::tokenize(NEDOS_OPTION.content_string, tokens, string(" "));
            if (tokens.size() != 1) {
              throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"NEDOS. Specify as NEDOS=5000.", _INPUT_ILLEGAL_);
            }
          }
          logger << (NEDOS_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "NEDOS=" << NEDOS_OPTION.content_string << "." << apl::endl;
        }
      }
    }
    //GP SUBDIRECTORY OPTIONS. These are automic options and not controlled by users
    CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_SD="), CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.xscheme);
    if(!CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option){
      CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_A_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_A_SD="), CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.xscheme);
      if(!CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option){
        CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_B_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_B_SD="), CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.xscheme);
        if(!CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option){
          CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "GRUNEISEN_C_SD=" + "|" + _ASTROPT_APL_OLD_ + "GRUNEISEN_C_SD="), CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option, CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.xscheme);
        }
      }
    }

    //Writing to log
    if(CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_SD=" << (CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_A_SD=" << (CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_B_SD=" << (CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GRUNEISEN_C_SD=" << (CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    }

    if(CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option|| CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option || CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option || CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option){
      GP_DISTORTION_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "GP_DISTORTION=" + "|" + _ASTROPT_APL_OLD_ + "GP_DISTORTION="), GP_DISTORTION_OPTION.option, GP_DISTORTION_OPTION.xscheme);
      GP_DISTORTION=GP_DISTORTION_OPTION.content_double;
      if (GP_DISTORTION_OPTION.isentry) {
        tokens.clear();
        apl::tokenize(GP_DISTORTION_OPTION.content_string, tokens, string(" "));
        if (tokens.size() != 1) {
          //ME20191031 - use xerror
          //throw apl::APLRuntimeError("Wrong setting in the "+_ASTROPT_+"GP_DISTORTION. Specify as GP_DISTORTION=0.03.");
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"GP_DISTORTION. Specify as GP_DISTORTION=0.03.", _INPUT_ILLEGAL_);
        }
      }
      logger << (GP_DISTORTION_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "GP_DISTORTION=" << GP_DISTORTION << "." << apl::endl;
    }
    //EOS SUBDIRECTORY OPTIONS. These are automic options and not controlled by users
    CALCULATE_EOS_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "EOS_SD=" + "|" + _ASTROPT_APL_OLD_ + "EOS_SD="), CALCULATE_EOS_SUBDIRECTORIES_OPTION.option, CALCULATE_EOS_SUBDIRECTORIES_OPTION.xscheme); //CO20170601
    if(CALCULATE_EOS_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_EOS_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "EOS_SD=" << (CALCULATE_EOS_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
      EOS_DISTORTION_RANGE_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "EOS_DISTORTION_RANGE=" + "|" + _ASTROPT_APL_OLD_ + "EOS_DISTORTION_RANGE="), EOS_DISTORTION_RANGE_OPTION.option, EOS_DISTORTION_RANGE_OPTION.xscheme); //CO20170601
      tokens.clear();
      apl::tokenize(EOS_DISTORTION_RANGE_OPTION.content_string, tokens, string(" :"));
      if (tokens.size() != 3) {
        //ME20191031 - use xerror
        //throw apl::APLRuntimeError("Wrong setting in the "+_ASTROPT_+"EOS_DISTORTION_RANGE. Specify as EOS_DISTORTION_RANGE=-3:6:1");
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"EOS_DISTORTION_RANGE. Specify as EOS_DISTORTION_RANGE=-3:6:1", _INPUT_ILLEGAL_);
      }
      EOS_DISTORTION_START = aurostd::string2utype<double>(tokens.at(0));
      EOS_DISTORTION_END = aurostd::string2utype<double>(tokens.at(1));
      EOS_DISTORTION_DISTORTION_INC = aurostd::string2utype<double>(tokens.at(2));
      logger << (EOS_DISTORTION_RANGE_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "EOS_DISTORTION_RANGE=" << EOS_DISTORTION_RANGE_OPTION.content_string << "." << apl::endl;
      logger << "The EOS properties will be calculated in distortion range <" << EOS_DISTORTION_START << "," << EOS_DISTORTION_END << "," << EOS_DISTORTION_DISTORTION_INC << "." << apl::endl;
    }

    //SCQHA SUBDIRECTORY OPTIONS. These are automic options and not controlled by users
    CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_SD="), CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.xscheme);
    if(!CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option){
      CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_A_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_A_SD="), CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.xscheme);
      if(!CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option){
        CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_B_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_B_SD="), CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.xscheme);
        if(!CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option){
          CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.options2entry(AflowIn, string(_ASTROPT_ + "SCQHA_C_SD=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_C_SD="), CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option,  CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.xscheme);
        }
      }
    }

    //Writing to log
    if(CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_SD=" << (CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_A_SD=" << (CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_B_SD=" << (CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    } else if(CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option){
      logger << (CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.isentry ? "Setting " : "DEFAULT ") << _ASTROPT_ << "SCQHA_C_SD=" << (CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option ? "ON" : "OFF") << "." << apl::endl;
    }

    if(CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option || CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option || CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option || CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.isentry){
      SCQHA_DISTORTION_OPTION.options2entry(AflowIn, string( _ASTROPT_ + "SCQHA_DISTORTION=" + "|" + _ASTROPT_APL_OLD_ + "SCQHA_DISTORTION="), SCQHA_DISTORTION_OPTION.option, SCQHA_DISTORTION_OPTION.xscheme);
      SCQHA_DISTORTION=SCQHA_DISTORTION_OPTION.content_double;
      if (SCQHA_DISTORTION_OPTION.isentry) {
        tokens.clear();
        apl::tokenize(SCQHA_DISTORTION_OPTION.content_string, tokens, string(" "));
        if (tokens.size() != 1) {
          //ME20190131 - use xerror
          //throw apl::APLRuntimeError("Wrong setting in the "+_ASTROPT_+"SCQHA_DISTORTION. Specify as SCQHA_DISTORTION=3.0.");
          throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Wrong setting in the "+_ASTROPT_+"SCQHA_DISTORTION. Specify as SCQHA_DISTORTION=3.0.", _INPUT_ILLEGAL_);
        }
      }
      logger << (SCQHA_DISTORTION_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "SCQHA_DISTORTION=" << SCQHA_DISTORTION << "." << apl::endl;
    }
    //PN QUASI-HARMONIC END


    //ME20181026 - OBSOLETE until it's properly documented
    //    // Get the users maximum shell which will be included into calculation
    //    //CO, not sure how maxshell works here (F option), need to investigate further and add to README
    //    // also seems USER_WANTS_FULL_SHELL applies for both MAX and MIN shell settings, should one take precedence? should they be separate flags?
    //    if(!found_supercell){
    //      USER_MAXSHELL_OPTION.options2entry(AflowIn, string( _ASTROPT_APL_ + "MAXSHELL=" + "|" + _ASTROPT_QHA_ + "MAXSHELL=" + "|" + _ASTROPT_AAPL_ + "MAXSHELL=" + "|" + _ASTROPT_APL_OLD_ + "MAXSHELL="), USER_MAXSHELL_OPTION.option, USER_MAXSHELL_OPTION.xscheme); //CO20170601
    //      test = USER_MAXSHELL_OPTION.content_string;
    //      if (test[test.size() - 1] == 'f' || test[test.size() - 1] == 'F') {
    //        USER_MAXSHELL = aurostd::string2utype<int>(test.substr(0, test.size() - 1));
    //        USER_WANTS_FULL_SHELL = true;
    //      } else {
    //        USER_MAXSHELL = USER_MAXSHELL_OPTION.content_int;
    //        USER_WANTS_FULL_SHELL = false;
    //      }
    //      if(USER_MAXSHELL_OPTION.isentry){
    //        logger << (USER_MAXSHELL_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "MAXSHELL=" << USER_MAXSHELL << (USER_WANTS_FULL_SHELL ? " (FULL)" : "") << "." << apl::endl;
    //        logger << "Supercell will be built with at most " << USER_MAXSHELL << " shells." << apl::endl;
    //        found_supercell = true;
    //      }
    //    }
    //
    //ME20181026 - F option OBSOLETE until it's properly documented
    //    // Get the users minimum shell which will be included into calculation
    //    //CO, not sure how minshell works here (F option), need to investigate further and add to README
    //    if(!found_supercell){
    //      USER_MINSHELL_OPTION.options2entry(AflowIn, string( _ASTROPT_APL_ + "MINSHELL=" + "|" + _ASTROPT_QHA_ + "MINSHELL=" + "|" + _ASTROPT_AAPL_ + "MINSHELL=" + "|" + _ASTROPT_APL_OLD_ + "MINSHELL="), USER_MINSHELL_OPTION.option, USER_MINSHELL_OPTION.xscheme); //CO20170601
    //      test = USER_MINSHELL_OPTION.content_string;
    //      if (test[test.size() - 1] == 'f' || test[test.size() - 1] == 'F') {
    //        USER_MINSHELL = aurostd::string2utype<int>(test.substr(0, test.size() - 1));
    //        USER_WANTS_FULL_SHELL = true;
    //      } else {
    //        USER_MINSHELL = USER_MINSHELL_OPTION.content_int;
    //        USER_WANTS_FULL_SHELL = false;
    //      }
    //      if(USER_MINSHELL_OPTION.isentry){
    //        logger << (USER_MINSHELL_OPTION.isentry ? "Setting" : "DEFAULT") << " " << _ASTROPT_ << "MINSHELL=" << USER_MINSHELL << (USER_WANTS_FULL_SHELL ? " (FULL)" : "") << "." << apl::endl;
    //        logger << "Supercell will be built with at least " << USER_MINSHELL << " shells." << apl::endl;
    //        found_supercell = true;
    //      }
    //    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                          PREPARE CALCULATIONS                           //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    //fix vasp bin for LR or DM+POLAR
    if (USER_ENGINE == string("LR") || (USER_ENGINE == string("DM") && USER_POLAR)) {
      if(xflags.AFLOW_MODE_VASP && !XHOST.GENERATE_AFLOWIN_ONLY){  //ME20190313 - Do not check the VASP binary for generate_aflowin_only
        try {
          // Check the version of VASP binary
          logger << "Checking VASP version for linear response calculations.";
          string vaspVersion;
          vaspVersion = getVASPVersionString( (kflags.KBIN_MPI ? kflags.KBIN_MPI_BIN : kflags.KBIN_BIN ) );
          if (!vaspVersion.empty()) {
            logger << "[" << vaspVersion[0] << "]";
            if ((vaspVersion[0] - '0') < 5) { //cool way of getting ascii value:  https://stackoverflow.com/questions/36310181/char-subtraction-in-c
              logger << apl::warning << "." << apl::endl;
              //ME20190107 - fix both serial and MPI binaries
              kflags.KBIN_SERIAL_BIN = DEFAULT_VASP5_BIN;
              kflags.KBIN_MPI_BIN = DEFAULT_VASP5_MPI_BIN;
              if (kflags.KBIN_MPI) {
                kflags.KBIN_BIN = kflags.KBIN_MPI_BIN;
              } else {
                kflags.KBIN_BIN = kflags.KBIN_SERIAL_BIN;
              }
              logger << apl::warning << "Modifying VASP bin to " << kflags.KBIN_BIN << " (AUTO modification)." << apl::endl;  //ME20190109
            } else {
              logger << " OK." << apl::endl;
            }
          } else {
            logger << "Failed." << apl::warning << apl::endl;
            throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Unexpected binary format.", _FILE_WRONG_FORMAT_);
          }
        } catch (aurostd::xerror& excpt) {
          logger << apl::warning << "Failed to identify the version of the VASP binary." << apl::endl;
          logger << apl::warning << excpt.error_message << apl::endl;
          //logger << apl::warning << excpt.what() << apl::endl;
        }
      }
    }

    // ME20200102 - BEGIN
    // The PHPOSCAR file now also serves as the canonical structure
    // for the phonon calculations. This prevents any changes in symmetry codes,
    // especially the structure conversion codes, from changing the structure
    // between AFLOW versions.
    string phposcar_file = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_PHPOSCAR_FILE);
    if (aurostd::EFileExist(phposcar_file)) {
      logger << "Reading structure from file " << phposcar_file << "." << apl::endl;
      xinput.getXStr() = xstructure(phposcar_file, IOVASP_POSCAR);
    }

    apl::Supercell supercell(xinput.getXStr(), messageFile, oss, aflags.Directory);
    // Determine the supercell dimensions
    xvector<int> scell_dims = supercell.determineSupercellDimensions(supercell_opts);

    // Don't relax when we already have a PHPOSCAR file (state saved)
    if (!aurostd::EFileExist(phposcar_file) && USER_RELAX) {
      // ME20190107 - Relax after fixing the vasp bin to make version consistent.
      // Run relaxations if necessary
      bool Krun=true;
      string function;
      if (xinput.AFLOW_MODE_VASP) {
        function = "KBIN::relaxStructureAPL_VASP";
        Krun = relaxStructureAPL_VASP(START_RELAX, AflowIn, supercell_opts, scell_dims,
            USER_RELAX_COMMENSURATE, xinput.xvasp, aflags, kflags, xflags.vflags, messageFile);
      }
      if (!Krun) {
        string message = "Relaxation calculations did not run successfully.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_,function, message, _RUNTIME_ERROR_);
      }

      // Reinitialize the supercell with the new structure
      supercell.initialize(xinput.getXStr());
    }

    // Build after relaxations are done
    supercell.build(scell_dims);
    if (USER_MAXSHELL > 0) supercell.setupShellRestrictions(USER_MAXSHELL);

    // ME20200427 - If NBANDS has been specified, store the number of supercells
    // to scale.
    if (xflags.vflags.KBIN_VASP_FORCE_OPTION_NBANDS_EQUAL.isentry) {
      int ncells = scell_dims[1] * scell_dims[2] * scell_dims[3];
      xinput.xvasp.aopts.push_attached("AFLOW_APL::NCELLS", aurostd::utype2string<int>(ncells));
    }

    // Write supercell input structure into PHPOSCAR to save state
    // unless it has been read before.
    if (!aurostd::EFileExist(phposcar_file)) {
      xstructure xstr = supercell.getInputStructureLight();
      xstr.is_vasp5_poscar_format = true;
      stringstream poscar;
      poscar << xstr;
      aurostd::stringstream2file(poscar, phposcar_file);
      if (!aurostd::FileExist(phposcar_file)) {
        string message = "Cannot open output file " + phposcar_file + ".";
        throw aurostd::xerror(_AFLOW_FILE_NAME_,function, message, _FILE_ERROR_);
      }
    }
    // ME20200102 - END

    //ME20190626 - Convert projection directions for DOS to Cartesian
    if ((USER_DOS_PROJECTIONS.size() > 0) && (!USER_DOS_PROJECTIONS_FRAC_SCHEME.empty())) {
      for (uint p = 0; p < USER_DOS_PROJECTIONS.size(); p++) {
        USER_DOS_PROJECTIONS[p] = xinput.getXStr().f2c * USER_DOS_PROJECTIONS[p];
      }
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           CALCULATE PHONONS                             //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    // Set up the phonon calculator
    apl::PhononCalculator phcalc(supercell, messageFile, oss);
    if (xflags.vflags.AFLOW_SYSTEM.content_string.empty()) {
      phcalc.setSystem(supercell.getInputStructure().title);
    } else {
      phcalc.setSystem(xflags.vflags.AFLOW_SYSTEM.content_string);
    }
    phcalc.setDirectory(aflags.Directory);
    phcalc.setNCPUs(kflags);
    phcalc.setPolarMaterial(USER_POLAR);

    // FORCE CONSTANTS ----------------------------------------------------------
    bool stagebreak = false;

    // Harmonic force constants
    string hibfile = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_HARMIFC_FILE);
    bool awakeHarmIFCs = (USER_HIBERNATE && aurostd::EFileExist(hibfile));
    bool apl_stagebreak = false;
    // Try to read first
    if (awakeHarmIFCs) {
      try {
        pflow::logger(_AFLOW_FILE_NAME_, "APL", "Awakening...", aflags, messageFile, oss);
        phcalc.awake();
      } catch (aurostd::xerror& e) {
        message = e.error_message + " Skipping awakening...";
        pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss, _LOGGER_WARNING_);
        awakeHarmIFCs = false;
      }
    }

    // Reading failed - calculate
    if (!awakeHarmIFCs) {
      // Set up calculator
      auto_ptr<apl::ForceConstantCalculator> fccalc;
      if (USER_ENGINE == string("DM")) {
        apl::DirectMethodPC*fccalcdm = new apl::DirectMethodPC(supercell, xinput, aflags,
            kflags, xflags, AflowIn, messageFile, oss);
        fccalcdm->setGeneratePlusMinus(USER_AUTO_DISTORTIONS, USER_DPM);  //CO auto
        fccalcdm->setGenerateOnlyXYZ(USER_DISTORTIONS_XYZ_ONLY);
        fccalcdm->setDistortionSYMMETRIZE(USER_DISTORTIONS_SYMMETRIZE);
        fccalcdm->setDistortionINEQUIVONLY(USER_DISTORTIONS_INEQUIVONLY); //CO20190131
        fccalcdm->setDistortionMagnitude(USER_DISTORTION_MAGNITUDE);
        fccalcdm->setCalculateZeroStateForces(USER_ZEROSTATE);
        fccalc.reset(fccalcdm);
        fccalc->setPolarMaterial(USER_POLAR);  // ME20200218
      } //CO20200106 - patching for auto-indenting
      //CO generally redirects to DM, the distinction between DM and GSA is obsolete
      //else if (USER_ENGINE == string("GSA")) {
      //  apl::GeneralizedSupercellApproach* gsa = new apl::GeneralizedSupercellApproach(supercell, strPair, xinput, aflags, kflags, xflags, logger);//xvasp, aflags, kflags, vflags, logger);  //Modified JJPR
      //  //gsa->setGeneratePlusMinus(USER_DISTORTIONS_PLUS_MINUS_OPTION.option); //CO auto
      //  gsa->setGeneratePlusMinus(AUTO_DISTORTIONS_PLUS_MINUS_OPTION.option, USER_DISTORTIONS_PLUS_MINUS_OPTION.option);  //CO auto
      //  gsa->setGenerateOnlyXYZ(USER_DISTORTIONS_XYZ_ONLY_OPTION.option);
      //  gsa->setDistortionMagnitude(USER_DISTORTION_MAGNITUDE);
      //  gsa->setTensor(CALCULATE_TCOND_OPTION.option);  // TCOND JJPR
      //  gsa->setSumRule(USER_EPS_SUM);           // TCOND JJPR
      //  //phcalcdm->setCalculateZeroStateForces(USER_ZEROSTATE_OPTION.option);
      //  phcalc.reset(gsa);
      //  } //CO20200106 - patching for auto-indenting
      else {
        fccalc.reset(new apl::LinearResponsePC(supercell, xinput, aflags,
              kflags, xflags, AflowIn, messageFile, oss));
        fccalc->setPolarMaterial(USER_POLAR);  // ME20200218
      }
      // Run calculations
      apl_stagebreak = fccalc->runVASPCalculations(USER_ZEROSTATE_CHGCAR);
      fccalc->saveState(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_STATE_FILE);
      if (!apl_stagebreak) {
        apl_stagebreak = !(fccalc->run());
        if (!apl_stagebreak) {
          if (USER_HIBERNATE) fccalc->hibernate();
          phcalc.setHarmonicForceConstants(*fccalc);
        }
      }
    }

    stagebreak = (stagebreak || apl_stagebreak);

    //QHA/SCQHA/QHA3P  START //PN20180705
    // Create directories for QHA/SCQHA/QHA3P
    // The pointer pheos should be called before creation of apl.xml
    auto_ptr<apl::QHA_AFLOWIN_CREATOR> pheos;
    if(CALCULATE_GRUNEISEN_OPTION.option || CALCULATE_GRUNEISEN_A_OPTION.option || CALCULATE_GRUNEISEN_B_OPTION.option || CALCULATE_GRUNEISEN_C_OPTION.option ||
        CALCULATE_SCQHA_OPTION.option || CALCULATE_SCQHA_A_OPTION.option || CALCULATE_SCQHA_B_OPTION.option || CALCULATE_SCQHA_C_OPTION.option ||
        CALCULATE_QHA3P_OPTION.option || CALCULATE_QHA3P_A_OPTION.option || CALCULATE_QHA3P_B_OPTION.option || CALCULATE_QHA3P_C_OPTION.option)
    {
      pheos.reset(new apl::QHA_AFLOWIN_CREATOR(supercell, xinput, aflags,
            kflags, xflags, AflowIn, messageFile, oss));

      pheos->setGP(CALCULATE_GRUNEISEN_OPTION.option, CALCULATE_GRUNEISEN_A_OPTION.option, CALCULATE_GRUNEISEN_B_OPTION.option, CALCULATE_GRUNEISEN_C_OPTION.option);
      if( CALCULATE_SCQHA_OPTION.option || CALCULATE_SCQHA_A_OPTION.option || CALCULATE_SCQHA_B_OPTION.option || CALCULATE_SCQHA_C_OPTION.option )
      {
        pheos->setSCGP(CALCULATE_SCQHA_OPTION.option, CALCULATE_SCQHA_A_OPTION.option, CALCULATE_SCQHA_B_OPTION.option, CALCULATE_SCQHA_C_OPTION.option);
      }
      if( CALCULATE_QHA3P_OPTION.option || CALCULATE_QHA3P_A_OPTION.option || CALCULATE_QHA3P_B_OPTION.option || CALCULATE_QHA3P_C_OPTION.option )
      {
        pheos->setSCGP(CALCULATE_QHA3P_OPTION.option, CALCULATE_QHA3P_A_OPTION.option, CALCULATE_QHA3P_B_OPTION.option, CALCULATE_QHA3P_C_OPTION.option);
      }

      pheos->setGP_VOL_DISTORTION(GP_DISTORTION);
      if(CALCULATE_SCQHA_OPTION.option || CALCULATE_SCQHA_A_OPTION.option || CALCULATE_SCQHA_B_OPTION.option || CALCULATE_SCQHA_C_OPTION.option ||
          CALCULATE_QHA3P_OPTION.option || CALCULATE_QHA3P_A_OPTION.option || CALCULATE_QHA3P_B_OPTION.option|| CALCULATE_QHA3P_C_OPTION.option){
        pheos->setSCGP_VOL_DISTORTION(SCQHA_DISTORTION);
      }
      if(CALCULATE_EOS_OPTION.option){
        pheos->setEOS(CALCULATE_EOS_OPTION.option);
        pheos->setEOS_distortion_range(EOS_DISTORTION_START, EOS_DISTORTION_END, EOS_DISTORTION_DISTORTION_INC);
        pheos->setEOS_STATIC_KPPRA(EOS_STATIC_KPPRA);
        pheos->setEOS_NEDOS(NEDOS);
        pheos->set_edos_accurate(EDOS_ACURATE_OPTION.option);
      }
      pheos->run_qha();
      pheos->close_log();
    }
    //QHA/SCQHA/QHA3P END

    // Anharmonic force constants
    bool aapl_stagebreak = false;
    if (USER_TCOND) {
      int max_order = (USER_AAPL_FOURTH_ORDER ? 4 : 3);
      for (int o = 3; o <= max_order; o++) {
        // Try and load IFCs from file
        string ifcs_hib_file = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_AAPL_FILE_PREFIX + _ANHARMONIC_IFCS_FILE_[o-3]);
        bool awakeAnharmIFCs = (USER_HIBERNATE && aurostd::EFileExist(ifcs_hib_file));
        if (awakeAnharmIFCs) {
          try {
            message = "Reading anharmonic IFCs from " + ifcs_hib_file + ".";
            pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
            phcalc.readAnharmonicIFCs(ifcs_hib_file);
          } catch (aurostd::xerror& excpt) {
            message = excpt.error_message + " Skipping awakening of ";
            if (o == 3) message += "3rd";
            else message += aurostd::utype2string<int>(o) + "th";
            message = excpt.error_message + " order anharmonic IFCs.";
            pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
            awakeAnharmIFCs = false;
          }
        }

        // Reading failed - calculate
        if (!awakeAnharmIFCs) {
          // Clusters
          apl::ClusterSet clst;
          string clust_hib_file = aflags.Directory + "/" + DEFAULT_AAPL_FILE_PREFIX + _CLUSTER_SET_FILE_[o-3];
          bool awakeClusterSet = (USER_HIBERNATE && aurostd::EFileExist(clust_hib_file));
          if (awakeClusterSet) {
            try {
              clst = apl::ClusterSet(clust_hib_file, supercell, USER_CUTOFF_SHELL[o-3],
                  USER_CUTOFF_DISTANCE[o-3], o, messageFile, aflags, oss);
            } catch (aurostd::xerror excpt) {
              message = excpt.error_message;
              pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
              awakeClusterSet = false;
            }
          }
          // Reading clusters failed - determine
          if (!awakeClusterSet) {
            clst = apl::ClusterSet(supercell, USER_CUTOFF_SHELL[o-3],
                USER_CUTOFF_DISTANCE[o-3], messageFile, aflags, oss);
            clst.build(o);
            clst.buildDistortions();
            if (USER_HIBERNATE) {
              clst.writeClusterSetToFile(clust_hib_file);
            }
          }
          // Setup calculations
          apl::AnharmonicIFCs anharm(xinput, aflags, kflags, xflags, clst, messageFile, oss);
          anharm.setOptions(USER_DISTORTION_MAGNITUDE, USER_AAPL_MAX_ITER, USER_AAPL_MIX, USER_EPS_SUM, USER_ZEROSTATE);
          aapl_stagebreak = (anharm.runVASPCalculations(USER_ZEROSTATE_CHGCAR) || aapl_stagebreak);
          // Calculate IFCs
          if (!aapl_stagebreak) {
            aapl_stagebreak = !(anharm.calculateForceConstants());
            if (!aapl_stagebreak) {
              if (USER_HIBERNATE) anharm.writeIFCsToFile(ifcs_hib_file);
              phcalc.setAnharmonicForceConstants(anharm);
            }
          }
        }
      }
    }
    //ME201901029 BEGIN
    stagebreak = (stagebreak || aapl_stagebreak);

    // Run ZEROSTATE calculation if ZEROSTATE CHGCAR
    if (USER_ZEROSTATE_CHGCAR && !XHOST.GENERATE_AFLOWIN_ONLY) {
      // Find ZEROSTATE directory
      vector<string> directory;
      aurostd::DirectoryLS(aflags.Directory, directory);
      uint ndir = directory.size();
      uint d = 0;
      for (d = 0; d < ndir; d++) {
        if (aurostd::IsDirectory(aflags.Directory + "/" + directory[d]) && aurostd::substring2bool(directory[d], "ZEROSTATE")) {
          break;
        }
      }
      if (d == ndir) {
        string message = "Could not find ZEROSTATE directory. ZEROSTATE_CHGCAR will be skipped.";
        pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss, _LOGGER_WARNING_);
        USER_ZEROSTATE_CHGCAR = false;
      } else {
        string chgcar_file = aurostd::CleanFileName("../" + directory[d] + "/CHGCAR.static");
        if (kflags.KZIP_COMPRESS) chgcar_file += "." + kflags.KZIP_BIN;
        if (!aurostd::FileExist(chgcar_file)) {
          logger << "Executing ZEROSTATE directory." << apl::endl;
          stringstream cmd;
          cmd << "aflow --use_aflow.in=" << _AFLOWIN_
            << " --use_LOCK=" << _AFLOWLOCK_
            << " --quiet -D ./" << directory[d];
          aurostd::execute(cmd.str());
          logger << "Finished executing ZEROSTATE directory." << apl::endl;
        }
      }
    }

    // At least one calculation has not finished - return
    if (stagebreak) {
      logger << apl::notice << "Stopped. Waiting for required calculations..." << apl::endl;  //CO20181226
      return;
    }
    //ME201901029 END

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                            QUASI-HARMONIC                               //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    //QHA/SCQHA/QHA3P START //PN20180705
    //Store dynamical matrices and PDOS from different distorted directores
    if(CALCULATE_GRUNEISEN_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_GRUNEISEN_A_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_GRUNEISEN_B_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_GRUNEISEN_C_SUBDIRECTORIES_OPTION.option)
    { 
      apl::QHAsubdirectoryData store(phcalc, logger);
      store.setdir_prefix(_TMPDIR_);
      string dirname = store.getdir_name(aflags.Directory);
      store.set_gp_vol_distortion(GP_DISTORTION);
      //create uniform q-mesh
      store.createMPmesh(USER_DOS_MESH[0], USER_DOS_MESH[1], USER_DOS_MESH[2],
          phcalc.getInputCellStructure());

      //check the distorted directort contains Gruneisen ON //PN20180705
      if(store.check_GP()){ //PN20180705
        //store dynamical matrices //PN20180705
        store.create_dm(); //PN20180705
        apl::PhononDispersionCalculator pdisc(phcalc);

        // Init path according to the aflow's definition for elec. struc.
        // ME20181029 - Restructured
        if (USER_DC_METHOD == "LATTICE") {
          pdisc.initPathLattice(USER_DC_INITLATTICE,USER_DC_NPOINTS);
        } else {
          if (!USER_DC_INITCOORDS_LABELS.empty() && !USER_DC_INITCOORDS_FRAC.empty()) {
            pdisc.initPathCoords(USER_DC_INITCOORDS_FRAC, USER_DC_INITCOORDS_LABELS, USER_DC_NPOINTS, false);
          } else if (!USER_DC_INITCOORDS_LABELS.empty() && !USER_DC_INITCOORDS_CART.empty()) {
            pdisc.initPathCoords(USER_DC_INITCOORDS_CART, USER_DC_INITCOORDS_LABELS, USER_DC_NPOINTS, true);
          }
        }
        //ME20190501 Allow user to override path
        if(!USER_DC_USERPATH.empty()){  // Set path
          pdisc.setPath(USER_DC_USERPATH);
        }

        std::vector<xvector<double> > qpoints = pdisc.get_qpoints();
        //store dynamical matrices along path //PN20180705
        store.create_pdispath(qpoints);
        qpoints.clear();
      }
      store.clear(); //PN20180705
      return; //PN20180705
    } //PN20180705
    //store PDOS from different distorted directories
    if(CALCULATE_EOS_SUBDIRECTORIES_OPTION.option)
    {
      apl::QHAsubdirectoryData store(phcalc, logger);
      store.setdir_prefix(_TMPDIR_);
      string dirname=store.getdir_name(aflags.Directory);
      // ME20190428 - START
      apl::QMesh qmesh(messageFile, oss);
      qmesh.setDirectory(aflags.Directory);
      qmesh.initialize(USER_DOS_MESH, phcalc.getInputCellStructure());
      if (USER_DOS_PROJECTIONS.size() == 0) qmesh.makeIrreducible();  // ME20190625

      apl::DOSCalculator dosc(phcalc, qmesh, USER_DOS_METHOD, USER_DOS_PROJECTIONS);
      //ME20190428 END
      // Calculate DOS
      dosc.calc(USER_DOS_NPOINTS, USER_DOS_SMEAR);
      if (USER_DOS) dosc.writePDOS(_TMPDIR_, dirname);
      store.clear();
      return;
    }
    //SCQHA and QHA3P save dynamical matrices and PDOS from different distorted directories
    if(CALCULATE_SCQHA_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_SCQHA_A_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_SCQHA_B_SUBDIRECTORIES_OPTION.option ||
        CALCULATE_SCQHA_C_SUBDIRECTORIES_OPTION.option)
    {
      {
        apl::QHAsubdirectoryData store(phcalc, logger);
        store.setdir_prefix(_TMPDIR_);
        string dirname=store.getdir_name(aflags.Directory);
        store.set_sc_vol_distortion(SCQHA_DISTORTION);

        //create uniform q-mesh
        store.createMPmesh(USER_DOS_MESH[0], USER_DOS_MESH[1], USER_DOS_MESH[2],
            phcalc.getInputCellStructure());

        if(store.check_SCQHA())
        {
          store.create_dm();
          apl::PhononDispersionCalculator pdisc(phcalc);

          // Init path according to the aflow's definition for elec. struc.
          //ME20181029 - Restructured
          if (USER_DC_METHOD == "LATTICE") {
            pdisc.initPathLattice(USER_DC_INITLATTICE,USER_DC_NPOINTS);
          } else {
            if (!USER_DC_INITCOORDS_LABELS.empty() && !USER_DC_INITCOORDS_FRAC.empty()) {
              pdisc.initPathCoords(USER_DC_INITCOORDS_FRAC, USER_DC_INITCOORDS_LABELS, USER_DC_NPOINTS, false);
            } else if (!USER_DC_INITCOORDS_LABELS.empty() && !USER_DC_INITCOORDS_CART.empty()) {
              pdisc.initPathCoords(USER_DC_INITCOORDS_CART, USER_DC_INITCOORDS_LABELS, USER_DC_NPOINTS, true);
            }
          }
          // ME20190501 Allow user to override path
          if(!USER_DC_USERPATH.empty()) {  // Set path
            pdisc.setPath(USER_DC_USERPATH);
          }

          std::vector< xvector<double> > qpoints=pdisc.get_qpoints();
          store.create_pdispath(qpoints);
          qpoints.clear();
        }
        {
          //ME20190428 BEGIN
          apl::QMesh qmesh(messageFile, oss);
          qmesh.setDirectory(aflags.Directory);
          qmesh.initialize(USER_DOS_MESH, phcalc.getInputCellStructure());
          if (USER_DOS_PROJECTIONS.size() == 0) qmesh.makeIrreducible();  // ME20190625

          apl::DOSCalculator dosc(phcalc, qmesh, USER_DOS_METHOD, USER_DOS_PROJECTIONS);
          //ME20190428 END
          // Calculate DOS
          dosc.calc(USER_DOS_NPOINTS,USER_DOS_SMEAR);
          if(USER_DOS)dosc.writePDOS(_TMPDIR_, dirname);
        }
        store.clear();
      }
      return;
    }
    //PN QHA/SCQHA/QHA3P  END

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           PHONON PROPERTIES                             //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    // Get the format of frequency desired by user ///////////////////////

    apl::IPCFreqFlags frequencyFormat = apl::NONE;

    if (!USER_FREQFORMAT.empty()) {
      //     try {
      // Convert format to machine representation
      tokens.clear();
      apl::tokenize(USER_FREQFORMAT, tokens, string(" |:;,"));
      for (uint i = 0; i < tokens.size(); i++) {
        if (tokens.at(i) == string("OMEGA")) {
          frequencyFormat |= apl::OMEGA;
          continue;
        }
        if (tokens.at(i) == string("HERTZ")) {
          frequencyFormat |= apl::HERTZ;
          continue;
        } else if (tokens.at(i) == string("THZ")) {
          frequencyFormat |= apl::THZ;
          continue;
        } else if (tokens.at(i) == string("CM-1") || tokens.at(i) == string("RECIPROCAL_CM")) {
          frequencyFormat |= apl::RECIPROCAL_CM;
          continue;
        } else if (tokens.at(i) == string("MEV")) {
          frequencyFormat |= apl::MEV;
          continue;
        }
        if (tokens.at(i) == string("ALLOW_NEGATIVE")) {
          frequencyFormat |= apl::ALLOW_NEGATIVE;
          continue;
        }
      }
      // Check if there was specified unit keyword...
      if (((frequencyFormat & ~apl::OMEGA) & ~apl::ALLOW_NEGATIVE) == apl::NONE)
        throw aurostd::xerror(_AFLOW_FILE_NAME_, function, "Ambiguous frequency format.", _INPUT_AMBIGUOUS_);
    } else {
      frequencyFormat = apl::THZ | apl::ALLOW_NEGATIVE;
    }

    //high-symmery qpoint auto pointer [PN] //PN20180705
    auto_ptr<apl::PhononHSQpoints> ptr_hsq;
    bool is_negative_freq=false;
    bool scqha_is_vol_err=false;
    //high-symmery qpoint auto pointer END [PN]

    // PHONON DISPERSIONS ---------------------------------------------------------

    if (USER_DC) {
      apl::PhononDispersionCalculator pdisc(phcalc);

      // Init path according to the aflow's definition for elec. struc.
      //ME20181029 - Restructured
      if (USER_DC_METHOD == "LATTICE") {
        if (!supercell.projectToPrimitive()) {  //ME20200117 - project to primitive
          message = "Could not map the AFLOW standard primitive cell to the supercell.\
                     Phonon dispersions will be calculated using the original structure instead.";
          pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, messageFile, oss, _LOGGER_WARNING_);
        }
        pdisc.initPathLattice(USER_DC_INITLATTICE,USER_DC_NPOINTS);
      } else {
        if (!USER_DC_INITCOORDS_LABELS.empty() && !USER_DC_INITCOORDS_FRAC.empty()) {
          pdisc.initPathCoords(USER_DC_INITCOORDS_FRAC, USER_DC_INITCOORDS_LABELS, USER_DC_NPOINTS, false);
        } else if (!USER_DC_INITCOORDS_LABELS.empty() && !USER_DC_INITCOORDS_CART.empty()) {
          pdisc.initPathCoords(USER_DC_INITCOORDS_CART, USER_DC_INITCOORDS_LABELS, USER_DC_NPOINTS, true);
        }
      }
      // ME20190501 Allow user to override path
      if(!USER_DC_USERPATH.empty()){  // Set path
        pdisc.setPath(USER_DC_USERPATH);
      }

      // Calculate frequencies on path
      pdisc.calc(frequencyFormat);

      // Write results into PDIS file
      pdisc.writePDIS(aflags.Directory);
      pdisc.writePHEIGENVAL(aflags.Directory);  //ME20190614
      if (USER_DC_METHOD == "LATTICE") supercell.projectToOriginal();  //ME20200117 - reset to original
      //QHA/SCQHA/QHA3P  START //PN20180705
      //////////////////////////////////////////////////////////////////////
      ptr_hsq.reset(new apl::PhononHSQpoints(logger));
      ptr_hsq->read_qpointfile(aflags.Directory);
      //compute Gruneisen dispersion curve
      if (CALCULATE_GRUNEISEN_OPTION.option ||
          CALCULATE_GRUNEISEN_A_OPTION.option ||
          CALCULATE_GRUNEISEN_B_OPTION.option ||
          CALCULATE_GRUNEISEN_C_OPTION.option)
      {
        apl::QHA qha(phcalc, *pheos, logger);
        qha.get_tmp_dir_name(_TMPDIR_);
        qha.set_cutoff_freq(CUTOFF_FREQ);
        if(qha.set_imported_variables())
        {
          if(qha.calculation_gruneisen(ptr_hsq->get_qpoints()))
          {
            qha.write_gruneisen_parameter_path(ptr_hsq->get_path(), ptr_hsq->get_path_segment());
            is_negative_freq=qha.get_is_negative_freq();
          }
        }
        qha.clear();
      }
      //QHA/SCQHA/QHA3P  END
    }

    // PHONON DOS AND THERMODYNAMIC PROPERTIES ----------------------------------------

    if (USER_DOS || USER_TP) {
      // Generate mesh for calculation of DOS...
      //ME20190428 START

      apl::QMesh qmesh(messageFile, oss);
      qmesh.setDirectory(aflags.Directory);
      qmesh.initialize(USER_DOS_MESH, phcalc.getInputCellStructure());
      if (USER_DOS_PROJECTIONS.size() == 0) qmesh.makeIrreducible();  //ME20190625

      // Calculate DOS
      apl::DOSCalculator dosc(phcalc, qmesh, USER_DOS_METHOD, USER_DOS_PROJECTIONS);
      // ME20190428 END
      dosc.calc(USER_DOS_NPOINTS, USER_DOS_SMEAR);
      if (USER_DOS) {
        dosc.writePDOS(aflags.Directory);
        dosc.writePHDOSCAR(aflags.Directory);  //ME20190614
      }

      // Calculate thermal properties
      if (USER_TP) {
        //if (!dosc.hasNegativeFrequencies()) //ME20200210 - Do not skip, just ignore contributions of imaginary frequencies and throw a warning
        apl::ThermalPropertiesCalculator tpc(dosc, messageFile, oss, aflags.Directory);  //ME20190423
        // ME20200108 - new ThermalPropertiesCalculator format
        tpc.calculateThermalProperties(USER_TP_TSTART, USER_TP_TEND, USER_TP_TSTEP);
        tpc.writePropertiesToFile(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_THERMO_FILE);

        if (USER_DISPLACEMENTS) {
          apl::AtomicDisplacements ad(phcalc);
          ad.calculateMeanSquareDisplacements(qmesh, USER_TP_TSTART, USER_TP_TEND, USER_TP_TSTEP);
          ad.writeMeanSquareDisplacementsToFile(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_MSQRDISP_FILE);
        }
        //QHA/SCQHA/QHA3P START //PN20180705
        //calculate Gruneisen
        //ME20190428 START
        //calculate group velocities
        if (!dosc.hasNegativeFrequencies()) {  // ME20200210
          if(CALCULATE_GROUPVELOCITY_OPTION.option){
            apl::GroupVelocity vg(phcalc, qmesh, logger);
            if(vg.check_negative_frequencies()){
              vg.write();
              vg.clear();
            }}
          //ME20190428 END
          //QHA calculate Gruneisen
          std::vector< std::vector< double> > scqha_tv;
          if (CALCULATE_GRUNEISEN_OPTION.option   ||
              CALCULATE_GRUNEISEN_A_OPTION.option ||
              CALCULATE_GRUNEISEN_B_OPTION.option ||
              CALCULATE_GRUNEISEN_C_OPTION.option) {
            if(!is_negative_freq){
              apl::QHA qha(phcalc, *pheos, logger);
              qha.get_tmp_dir_name(_TMPDIR_);
              qha.set_cutoff_freq(CUTOFF_FREQ);
              if(qha.set_imported_variables())
              {
                //QHA Grunneisen parameter calculations     
                if(qha.calculation_gruneisen(&qmesh))  //ME20190428
                {
                  qha.write_gruneisen_parameter_mesh();
                  qha.Writeaverage_gp(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP);
                  is_negative_freq=qha.get_is_negative_freq();
                }
                //[OBSOLETE PN20180705]eos.clear();
              }
              if(CALCULATE_EOS_OPTION.option)
              {
                //QHA EOS calculations
                //[CO20181202 - NOT USED]apl::QH_ENERGIES eos_ens(*phcalc, *pheos, logger);
                apl::QH_ENERGIES eos_ens(*pheos, logger);
                eos_ens.get_tmp_dir_name(_TMPDIR_);
                eos_ens.get_xtracture(phcalc.getInputCellStructure());
                if(eos_ens.get_qha_energies())
                {     
                  apl::QHAEOS qheos(qha, eos_ens, logger);
                  qheos.set_fitting_type(FITTING_TYPE);
                  if(qheos.setvariables())
                  { 
                    qheos.set_include_ele(INCLUDE_ELE_OPTION.option);
                    qheos.cal_qheos(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP, tpc);
                  }
                  qheos.clear();
                  qha.clear();
                  //QHA3P and SCQHA calculations
                  if( (CALCULATE_SCQHA_OPTION.option || 
                        CALCULATE_SCQHA_A_OPTION.option || 
                        CALCULATE_SCQHA_B_OPTION.option || 
                        CALCULATE_SCQHA_C_OPTION.option ||
                        CALCULATE_QHA3P_OPTION.option || 
                        CALCULATE_QHA3P_A_OPTION.option || 
                        CALCULATE_QHA3P_B_OPTION.option || 
                        CALCULATE_QHA3P_C_OPTION.option) && (!scqha_is_vol_err) )
                  {         
                    if(!is_negative_freq){
                      apl::SCQHA_QHA3P scqha(phcalc, *pheos, logger);
                      scqha.get_tmp_dir_name(_TMPDIR_);
                      scqha.set_cutoff_freq(CUTOFF_FREQ);
                      if(scqha.set_imported_variables())
                      {    
                        //QHA3P Gruneisen parameter calculations 
                        //if(scqha.calculation_gruneisen(&umesh))  OBSOLETE ME20190428
                        if(scqha.calculation_gruneisen(&qmesh))  //ME20190428
                        {
                          if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                          { //PN 180719
                            scqha.write_gruneisen_parameter_mesh();
                            scqha.Writeaverage_gp(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP);
                            is_negative_freq=scqha.get_is_negative_freq();
                          }
                        }
                        //[OBSOLETE PN20180705]pheos->clear();
                      }
                      if(!is_negative_freq) //PN20180705
                      {   
                        //SCQHA EOS
                        if(kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A)
                        {
                          apl::SCQHAEOS scqhaeos(scqha, eos_ens, logger);
                          if(scqhaeos.import_variables())
                          { 
                            scqhaeos.set_input_temperature(scqha_pdis_T);
                            scqhaeos.sccycle(USER_TP_TSTART,USER_TP_TEND, 0.1);
                            scqha_tv=scqhaeos.get_TV_data();
                          } 
                          scqhaeos.clear();
                        }
                        //QHA3P EOS
                        if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                        {
                          apl::QHA3POINTS qha3points(scqha, eos_ens, logger);
                          if(qha3points.import_variables())
                          {
                            qha3points.set_include_ele(INCLUDE_ELE_OPTION.option);
                            qha3points.qha3pts_temperature_loop(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP, tpc);
                          }
                          qha3points.clear();
                        }
                      }
                      eos_ens.clear();
                      scqha.clear();
                    }
                  }
                }
              }
            } //QHA3P and SCQHA calculations    
          } else if(kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A ||
              kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
          {
            //[CO20181202 - NOT USED]apl::QH_ENERGIES eos_ens(*phcalc, *pheos, logger);
            apl::QH_ENERGIES eos_ens(*pheos, logger);
            eos_ens.get_xtracture(phcalc.getInputCellStructure());
            eos_ens.get_tmp_dir_name(_TMPDIR_);
            if(eos_ens.get_scqha_energies())
            {
              if(!is_negative_freq){
                apl::SCQHA_QHA3P scqha(phcalc, *pheos, logger);
                scqha.get_tmp_dir_name(_TMPDIR_);
                scqha.set_cutoff_freq(CUTOFF_FREQ);
                if(scqha.set_imported_variables())
                {
                  //QHA3P Gruneisen parameter calculation
                  if(scqha.calculation_gruneisen(&qmesh))  //ME20190428
                  {
                    if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                    { //PN 180719
                      scqha.write_gruneisen_parameter_mesh();
                      scqha.Writeaverage_gp(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP);
                      is_negative_freq=scqha.get_is_negative_freq();
                    }
                  }
                }
                if(!is_negative_freq)
                {
                  //SCQHA calculations
                  if(kflags.KBIN_PHONONS_CALCULATION_SCQHA || kflags.KBIN_PHONONS_CALCULATION_SCQHA_A || kflags.KBIN_PHONONS_CALCULATION_SCQHA_B || kflags.KBIN_PHONONS_CALCULATION_SCQHA_C)
                  {
                    apl::SCQHAEOS scqhaeos(scqha, eos_ens, logger);
                    if(scqhaeos.import_variables())
                    {
                      scqhaeos.sccycle(USER_TP_TSTART,USER_TP_TEND, 0.1);
                    }
                    scqhaeos.clear();
                  }
                  //QHA3P calculations
                  if(kflags.KBIN_PHONONS_CALCULATION_QHA3P || kflags.KBIN_PHONONS_CALCULATION_QHA3P_A || kflags.KBIN_PHONONS_CALCULATION_QHA3P_B || kflags.KBIN_PHONONS_CALCULATION_QHA3P_C)
                  {
                    apl::QHA3POINTS qha3points(scqha, eos_ens, logger);
                    if(qha3points.import_variables())
                    {
                      qha3points.set_include_ele(INCLUDE_ELE_OPTION.option);
                      qha3points.qha3pts_temperature_loop(USER_TP_TSTART,USER_TP_TEND,USER_TP_TSTEP, tpc);
                    }
                    qha3points.clear();
                  }
                }
                scqha.clear();
              }
            }
            eos_ens.clear();
          }
          //compute SCQHA temperature dependent dispersion curve
          if((scqha_tv.size()!=0) && (SCQHA_PDIS_T_OPTION.option)){
            apl::T_spectra_SCQHA_QHA3P scqha_T(phcalc, *pheos, logger);
            scqha_T.get_tmp_dir_name(_TMPDIR_);
            scqha_T.set_cutoff_freq(CUTOFF_FREQ);
            scqha_T.get_input_data(scqha_tv);
            if(scqha_T.set_imported_variables())
            {
              if(scqha_T.calculation_freqs(ptr_hsq->get_qpoints()))
              {
                scqha_T.calculate_pdis_T(ptr_hsq->get_path(), ptr_hsq->get_path_segment());
              }
            }
            scqha_T.clear();
          }
          if(ptr_hsq.get()) ptr_hsq->clear();  // ME20190423
          //QHA/SCQHA/QHA3P END
        } else {
          // ME20200210 - changed warning
          const vector<double>& freqs = dosc.getBins();
          const vector<double>& idos = dosc.getIDOS();
          uint i = 0;
          for (i = 0; i < freqs.size(); i++) {
            if (freqs[i] > -_AFLOW_APL_EPS_) break;
          }
          double idos_percent = 100.0 * idos[i]/idos.back();
          // Cannot use std::setprecision with apl:logger, so use this workaround.
          stringstream percent;
          percent << std::fixed << std::setprecision(1) << idos_percent;
          logger << apl::warning << "There are imaginary frequencies in the phonon DOS, covering "
            << percent.str() << "\% of the integrated DOS. These frequencies were omitted in the "
            << "calculation of thermodynamic properties." << apl::endl;
        }
      }

      // Clear old stuff
      //delete dosc; //auto_ptr will do
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                         THERMAL CONDUCTIVITY                            //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (USER_TCOND) {
      // Get q-points
      message = "Starting thermal conductivity calculations.";
      pflow::logger(_AFLOW_FILE_NAME_, modulename, message, aflags, messageFile, oss);
      apl::QMesh qmtcond(messageFile, oss);
      qmtcond.setDirectory(aflags.Directory);
      qmtcond.initialize(USER_THERMALGRID, phcalc.getInputCellStructure(), true, true);
      qmtcond.makeIrreducible();
      qmtcond.writeQpoints(aflags.Directory + "/" + DEFAULT_AAPL_FILE_PREFIX + DEFAULT_AAPL_QPOINTS_FILE);
      qmtcond.writeIrredQpoints(aflags.Directory + "/" + DEFAULT_AAPL_FILE_PREFIX + DEFAULT_AAPL_IRRQPTS_FILE);

      // Do the thermal conductivity calculation
      apl::TCONDCalculator tcond(phcalc, qmtcond, aflags);

      // Set calculation options
      tcond.calc_options.flag("RTA", (USER_BTE == "RTA"));
      tcond.calc_options.flag("ISOTOPE", USER_ISOTOPE);
      tcond.calc_options.flag("BOUNDARY", USER_BOUNDARY);
      tcond.calc_options.flag("CUMULATIVE", USER_CUMULATIVEK);
      tcond.calc_options.flag("FOURTH_ORDER", USER_AAPL_FOURTH_ORDER);
      tcond.calc_options.push_attached("GRAIN_SIZE", aurostd::utype2string<double>(USER_NANO_SIZE));
      tcond.calc_options.push_attached("TSTART", aurostd::utype2string<double>(USER_TCT_TSTART));
      tcond.calc_options.push_attached("TEND", aurostd::utype2string<double>(USER_TCT_TEND));
      tcond.calc_options.push_attached("TSTEP", aurostd::utype2string<double>(USER_TCT_TSTEP));
      tcond.calc_options.push_attached("KZIP_BIN", kflags.KZIP_BIN);

      tcond.calculateThermalConductivity();
    }
    /*************** End Thermal Conductivity Calculations ****************/

  }
}

//////////////////////////////////////////////////////////////////////////////

bool PHON_RunPhonons(const xstructure& _str,
    _aflags& aflags,
    const double& _radius,
    const bool& osswrite, ostream& oss) {
  bool Krun = FALSE;
  oss << "not implemented" << endl;
  if (0) {  // to avoid warnings
    oss << _str << endl
      << aflags.QUIET << _radius << osswrite << endl;
  }
  return Krun;
}

// ***************************************************************************
// *                                                                         *
// *             STEFANO CURTAROLO - Duke University 2003-2020              *
// *                                                                         *
// ***************************************************************************
